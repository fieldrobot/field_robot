ARM GAS  /tmp/ccwN6eMm.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.SystemClock_Config,"ax",%progbits
  16              		.align	1
  17              		.global	SystemClock_Config
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	SystemClock_Config:
  24              	.LFB65:
  25              		.file 1 "Src/main.c"
   1:Src/main.c    **** /*
   2:Src/main.c    **** * This file is part of the hoverboard-firmware-hack project.
   3:Src/main.c    **** *
   4:Src/main.c    **** * Copyright (C) 2017-2018 Rene Hopf <renehopf@mac.com>
   5:Src/main.c    **** * Copyright (C) 2017-2018 Nico Stute <crinq@crinq.de>
   6:Src/main.c    **** * Copyright (C) 2017-2018 Niklas Fauth <niklas.fauth@kit.fail>
   7:Src/main.c    **** * Copyright (C) 2019-2020 Emanuel FERU <aerdronix@gmail.com>
   8:Src/main.c    **** *
   9:Src/main.c    **** * This program is free software: you can redistribute it and/or modify
  10:Src/main.c    **** * it under the terms of the GNU General Public License as published by
  11:Src/main.c    **** * the Free Software Foundation, either version 3 of the License, or
  12:Src/main.c    **** * (at your option) any later version.
  13:Src/main.c    **** *
  14:Src/main.c    **** * This program is distributed in the hope that it will be useful,
  15:Src/main.c    **** * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:Src/main.c    **** * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:Src/main.c    **** * GNU General Public License for more details.
  18:Src/main.c    **** *
  19:Src/main.c    **** * You should have received a copy of the GNU General Public License
  20:Src/main.c    **** * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:Src/main.c    **** */
  22:Src/main.c    **** 
  23:Src/main.c    **** #include <stdlib.h> // for abs()
  24:Src/main.c    **** #include "stm32f1xx_hal.h"
  25:Src/main.c    **** #include "defines.h"
  26:Src/main.c    **** #include "setup.h"
  27:Src/main.c    **** #include "config.h"
  28:Src/main.c    **** #include "util.h"
  29:Src/main.c    **** #include "comms.h"
  30:Src/main.c    **** #include "BLDC_controller.h"      /* BLDC's header file */
  31:Src/main.c    **** #include "rtwtypes.h"
  32:Src/main.c    **** 
  33:Src/main.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
ARM GAS  /tmp/ccwN6eMm.s 			page 2


  34:Src/main.c    **** #include "hd44780.h"
  35:Src/main.c    **** #endif
  36:Src/main.c    **** 
  37:Src/main.c    **** void SystemClock_Config(void);
  38:Src/main.c    **** 
  39:Src/main.c    **** //------------------------------------------------------------------------
  40:Src/main.c    **** // Global variables set externally
  41:Src/main.c    **** //------------------------------------------------------------------------
  42:Src/main.c    **** extern TIM_HandleTypeDef htim_left;
  43:Src/main.c    **** extern TIM_HandleTypeDef htim_right;
  44:Src/main.c    **** extern ADC_HandleTypeDef hadc1;
  45:Src/main.c    **** extern ADC_HandleTypeDef hadc2;
  46:Src/main.c    **** extern volatile adc_buf_t adc_buffer;
  47:Src/main.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  48:Src/main.c    ****   extern LCD_PCF8574_HandleTypeDef lcd;
  49:Src/main.c    ****   extern uint8_t LCDerrorFlag;
  50:Src/main.c    **** #endif
  51:Src/main.c    **** 
  52:Src/main.c    **** extern UART_HandleTypeDef huart2;
  53:Src/main.c    **** extern UART_HandleTypeDef huart3;
  54:Src/main.c    **** 
  55:Src/main.c    **** // Matlab defines - from auto-code generation
  56:Src/main.c    **** //---------------
  57:Src/main.c    **** extern P    rtP_Left;                   /* Block parameters (auto storage) */
  58:Src/main.c    **** extern P    rtP_Right;                  /* Block parameters (auto storage) */
  59:Src/main.c    **** extern ExtY rtY_Left;                   /* External outputs */
  60:Src/main.c    **** extern ExtY rtY_Right;                  /* External outputs */
  61:Src/main.c    **** //---------------
  62:Src/main.c    **** 
  63:Src/main.c    **** extern int16_t cmd1;                    // normalized input value. -1000 to 1000
  64:Src/main.c    **** extern int16_t cmd2;                    // normalized input value. -1000 to 1000
  65:Src/main.c    **** 
  66:Src/main.c    **** extern int16_t speedAvg;                // Average measured speed
  67:Src/main.c    **** extern int16_t speedAvgAbs;             // Average measured speed in absolute
  68:Src/main.c    **** extern volatile uint32_t timeoutCnt;    // Timeout counter for the General timeout (PPM, PWM, Nunch
  69:Src/main.c    **** extern uint8_t timeoutFlagADC;          // Timeout Flag for for ADC Protection: 0 = OK, 1 = Problem
  70:Src/main.c    **** extern uint8_t timeoutFlagSerial;       // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
  71:Src/main.c    **** 
  72:Src/main.c    **** extern volatile int pwml;               // global variable for pwm left. -1000 to 1000
  73:Src/main.c    **** extern volatile int pwmr;               // global variable for pwm right. -1000 to 1000
  74:Src/main.c    **** 
  75:Src/main.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  76:Src/main.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  77:Src/main.c    **** 
  78:Src/main.c    **** extern uint8_t enable;                  // global variable for motor enable
  79:Src/main.c    **** 
  80:Src/main.c    **** extern int16_t batVoltage;              // global variable for battery voltage
  81:Src/main.c    **** 
  82:Src/main.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
  83:Src/main.c    **** extern SerialSideboard Sideboard_L;
  84:Src/main.c    **** #endif
  85:Src/main.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
  86:Src/main.c    **** extern SerialSideboard Sideboard_R;
  87:Src/main.c    **** #endif
  88:Src/main.c    **** #if (defined(CONTROL_PPM_LEFT) && defined(DEBUG_SERIAL_USART3)) || (defined(CONTROL_PPM_RIGHT) && d
  89:Src/main.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  90:Src/main.c    **** #endif
ARM GAS  /tmp/ccwN6eMm.s 			page 3


  91:Src/main.c    **** #if (defined(CONTROL_PWM_LEFT) && defined(DEBUG_SERIAL_USART3)) || (defined(CONTROL_PWM_RIGHT) && d
  92:Src/main.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  93:Src/main.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  94:Src/main.c    **** #endif
  95:Src/main.c    **** 
  96:Src/main.c    **** 
  97:Src/main.c    **** //------------------------------------------------------------------------
  98:Src/main.c    **** // Global variables set here in main.c
  99:Src/main.c    **** //------------------------------------------------------------------------
 100:Src/main.c    **** uint8_t backwardDrive;
 101:Src/main.c    **** volatile uint32_t main_loop_counter;
 102:Src/main.c    **** 
 103:Src/main.c    **** //------------------------------------------------------------------------
 104:Src/main.c    **** // Local variables
 105:Src/main.c    **** //------------------------------------------------------------------------
 106:Src/main.c    **** #if defined(FEEDBACK_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USART3)
 107:Src/main.c    **** typedef struct{
 108:Src/main.c    ****   uint16_t  start;
 109:Src/main.c    ****   int16_t   cmd1;
 110:Src/main.c    ****   int16_t   cmd2;
 111:Src/main.c    ****   int16_t   speedR_meas;
 112:Src/main.c    ****   int16_t   speedL_meas;
 113:Src/main.c    ****   int16_t   batVoltage;
 114:Src/main.c    ****   int16_t   boardTemp;
 115:Src/main.c    ****   uint16_t 	cmdLed;
 116:Src/main.c    ****   uint16_t  checksum;
 117:Src/main.c    **** } SerialFeedback;
 118:Src/main.c    **** static SerialFeedback Feedback;
 119:Src/main.c    **** #endif
 120:Src/main.c    **** #if defined(FEEDBACK_SERIAL_USART2)
 121:Src/main.c    **** static uint8_t sideboard_leds_L;
 122:Src/main.c    **** #endif
 123:Src/main.c    **** #if defined(FEEDBACK_SERIAL_USART3)
 124:Src/main.c    **** static uint8_t sideboard_leds_R;
 125:Src/main.c    **** #endif
 126:Src/main.c    **** 
 127:Src/main.c    **** #ifdef VARIANT_TRANSPOTTER
 128:Src/main.c    ****   extern uint8_t  nunchuk_connected;
 129:Src/main.c    ****   extern float    setDistance;  
 130:Src/main.c    **** 
 131:Src/main.c    ****   static uint8_t  checkRemote = 0;
 132:Src/main.c    ****   static uint16_t distance;
 133:Src/main.c    ****   static float    steering;
 134:Src/main.c    ****   static int      distanceErr;  
 135:Src/main.c    ****   static int      lastDistance = 0;
 136:Src/main.c    ****   static uint16_t transpotter_counter = 0;
 137:Src/main.c    **** #endif
 138:Src/main.c    **** 
 139:Src/main.c    **** static int16_t    speed;                // local variable for speed. -1000 to 1000
 140:Src/main.c    **** #ifndef VARIANT_TRANSPOTTER
 141:Src/main.c    ****   static int16_t  steer;                // local variable for steering. -1000 to 1000
 142:Src/main.c    ****   static int16_t  steerRateFixdt;       // local fixed-point variable for steering rate limiter
 143:Src/main.c    ****   static int16_t  speedRateFixdt;       // local fixed-point variable for speed rate limiter
 144:Src/main.c    ****   static int32_t  steerFixdt;           // local fixed-point variable for steering low-pass filter
 145:Src/main.c    ****   static int32_t  speedFixdt;           // local fixed-point variable for speed low-pass filter
 146:Src/main.c    **** #endif
 147:Src/main.c    **** 
ARM GAS  /tmp/ccwN6eMm.s 			page 4


 148:Src/main.c    **** static uint32_t    inactivity_timeout_counter;
 149:Src/main.c    **** static MultipleTap MultipleTapBrake;    // define multiple tap functionality for the Brake pedal
 150:Src/main.c    **** 
 151:Src/main.c    **** 
 152:Src/main.c    **** int main(void) {
 153:Src/main.c    **** 
 154:Src/main.c    ****   HAL_Init();
 155:Src/main.c    ****   __HAL_RCC_AFIO_CLK_ENABLE();
 156:Src/main.c    ****   HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 157:Src/main.c    ****   /* System interrupt init*/
 158:Src/main.c    ****   /* MemoryManagement_IRQn interrupt configuration */
 159:Src/main.c    ****   HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 160:Src/main.c    ****   /* BusFault_IRQn interrupt configuration */
 161:Src/main.c    ****   HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 162:Src/main.c    ****   /* UsageFault_IRQn interrupt configuration */
 163:Src/main.c    ****   HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 164:Src/main.c    ****   /* SVCall_IRQn interrupt configuration */
 165:Src/main.c    ****   HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 166:Src/main.c    ****   /* DebugMonitor_IRQn interrupt configuration */
 167:Src/main.c    ****   HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 168:Src/main.c    ****   /* PendSV_IRQn interrupt configuration */
 169:Src/main.c    ****   HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 170:Src/main.c    ****   /* SysTick_IRQn interrupt configuration */
 171:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 172:Src/main.c    **** 
 173:Src/main.c    ****   SystemClock_Config();
 174:Src/main.c    **** 
 175:Src/main.c    ****   __HAL_RCC_DMA1_CLK_DISABLE();
 176:Src/main.c    ****   MX_GPIO_Init();
 177:Src/main.c    ****   MX_TIM_Init();
 178:Src/main.c    ****   MX_ADC1_Init();
 179:Src/main.c    ****   MX_ADC2_Init();
 180:Src/main.c    ****   BLDC_Init();        // BLDC Controller Init
 181:Src/main.c    ****   Input_Lim_Init();   // Input Limitations Init
 182:Src/main.c    ****   Input_Init();       // Input Init
 183:Src/main.c    **** 
 184:Src/main.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_SET);
 185:Src/main.c    **** 
 186:Src/main.c    ****   HAL_ADC_Start(&hadc1);
 187:Src/main.c    ****   HAL_ADC_Start(&hadc2);  
 188:Src/main.c    **** 
 189:Src/main.c    ****   poweronMelody();
 190:Src/main.c    ****   HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET);
 191:Src/main.c    **** 
 192:Src/main.c    ****   int16_t speedL     = 0, speedR     = 0;
 193:Src/main.c    ****   int16_t lastSpeedL = 0, lastSpeedR = 0;
 194:Src/main.c    **** 
 195:Src/main.c    ****   int32_t board_temp_adcFixdt = adc_buffer.temp << 16;  // Fixed-point filter output initialized wi
 196:Src/main.c    ****   int16_t board_temp_adcFilt  = adc_buffer.temp;
 197:Src/main.c    ****   int16_t board_temp_deg_c;
 198:Src/main.c    **** 
 199:Src/main.c    **** 
 200:Src/main.c    ****   while(1) {
 201:Src/main.c    ****     HAL_Delay(DELAY_IN_MAIN_LOOP);        //delay in ms
 202:Src/main.c    **** 
 203:Src/main.c    ****     readCommand();                        // Read Command: cmd1, cmd2
 204:Src/main.c    ****     calcAvgSpeed();                       // Calculate average measured speed: speedAvg, speedAvgAb
ARM GAS  /tmp/ccwN6eMm.s 			page 5


 205:Src/main.c    **** 
 206:Src/main.c    ****     #ifndef VARIANT_TRANSPOTTER
 207:Src/main.c    ****       // ####### MOTOR ENABLING: Only if the initial input is very small (for SAFETY) #######
 208:Src/main.c    ****       if (enable == 0 && (!rtY_Left.z_errCode && !rtY_Right.z_errCode) && (cmd1 > -50 && cmd1 < 50)
 209:Src/main.c    ****         shortBeep(6);                     // make 2 beeps indicating the motor enable
 210:Src/main.c    ****         shortBeep(4); HAL_Delay(100);
 211:Src/main.c    ****         enable = 1;                       // enable motors
 212:Src/main.c    ****         consoleLog("-- Motors enabled --\r\n");
 213:Src/main.c    ****       }
 214:Src/main.c    **** 
 215:Src/main.c    ****       // ####### VARIANT_HOVERCAR ####### 
 216:Src/main.c    ****       #if defined(VARIANT_HOVERCAR) || defined(VARIANT_SKATEBOARD) || defined(ELECTRIC_BRAKE_ENABLE
 217:Src/main.c    ****         uint16_t speedBlend;                                        // Calculate speed Blend, a num
 218:Src/main.c    ****         speedBlend = (uint16_t)(((CLAMP(speedAvgAbs,10,60) - 10) << 15) / 50); // speedBlend [0,1] 
 219:Src/main.c    ****       #endif
 220:Src/main.c    **** 
 221:Src/main.c    ****       #ifdef VARIANT_HOVERCAR        
 222:Src/main.c    ****         if (speedAvgAbs < 60) {                                     // Check if Hovercar is physica
 223:Src/main.c    ****           multipleTapDet(cmd1, HAL_GetTick(), &MultipleTapBrake);   // Brake pedal in this case is 
 224:Src/main.c    ****         }
 225:Src/main.c    ****         
 226:Src/main.c    ****         if (cmd1 > 30) {                                            // If Brake pedal (cmd1) is pre
 227:Src/main.c    ****           cmd2 = (int16_t)((cmd2 * speedBlend) >> 15);
 228:Src/main.c    ****         }
 229:Src/main.c    ****       #endif
 230:Src/main.c    **** 
 231:Src/main.c    ****       #ifdef ELECTRIC_BRAKE_ENABLE        
 232:Src/main.c    ****         electricBrake(speedBlend, MultipleTapBrake.b_multipleTap);  // Apply Electric Brake. Only a
 233:Src/main.c    ****       #endif
 234:Src/main.c    **** 
 235:Src/main.c    ****       #ifdef VARIANT_HOVERCAR        
 236:Src/main.c    ****         if (speedAvg > 0) {                                         // Make sure the Brake pedal is
 237:Src/main.c    ****           cmd1 = (int16_t)((-cmd1 * speedBlend) >> 15);
 238:Src/main.c    ****         } else {
 239:Src/main.c    ****           cmd1 = (int16_t)(( cmd1 * speedBlend) >> 15);
 240:Src/main.c    ****         }
 241:Src/main.c    ****       #endif
 242:Src/main.c    **** 
 243:Src/main.c    ****       #ifdef VARIANT_SKATEBOARD
 244:Src/main.c    ****         if (cmd2 < 0) {                                           // When Throttle is negative, it 
 245:Src/main.c    ****           if (speedAvg > 0) {                                     // Make sure the braking is oppos
 246:Src/main.c    ****             cmd2 = (int16_t)(( cmd2 * speedBlend) >> 15);
 247:Src/main.c    ****           } else {
 248:Src/main.c    ****             cmd2 = (int16_t)((-cmd2 * speedBlend) >> 15);
 249:Src/main.c    ****           }
 250:Src/main.c    ****         }
 251:Src/main.c    ****       #endif
 252:Src/main.c    **** 
 253:Src/main.c    ****       // ####### LOW-PASS FILTER #######
 254:Src/main.c    ****       rateLimiter16(cmd1, RATE, &steerRateFixdt);
 255:Src/main.c    ****       rateLimiter16(cmd2, RATE, &speedRateFixdt);
 256:Src/main.c    ****       filtLowPass32(steerRateFixdt >> 4, FILTER, &steerFixdt);
 257:Src/main.c    ****       filtLowPass32(speedRateFixdt >> 4, FILTER, &speedFixdt);
 258:Src/main.c    ****       steer = (int16_t)(steerFixdt >> 16);  // convert fixed-point to integer
 259:Src/main.c    ****       speed = (int16_t)(speedFixdt >> 16);  // convert fixed-point to integer
 260:Src/main.c    **** 
 261:Src/main.c    ****       #ifdef STANDSTILL_HOLD_ENABLE
ARM GAS  /tmp/ccwN6eMm.s 			page 6


 262:Src/main.c    ****         standstillHold(&speed);                 // Apply Standstill Hold functionality. Only availa
 263:Src/main.c    ****       #endif
 264:Src/main.c    **** 
 265:Src/main.c    ****       // ####### VARIANT_HOVERCAR #######
 266:Src/main.c    ****       #ifdef VARIANT_HOVERCAR        
 267:Src/main.c    ****         if (!MultipleTapBrake.b_multipleTap) {  // Check driving direction
 268:Src/main.c    ****           speed = steer + speed;                // Forward driving: in this case steer = Brake, spe
 269:Src/main.c    ****         } else {
 270:Src/main.c    ****           speed = steer - speed;                // Reverse driving: in this case steer = Brake, spe
 271:Src/main.c    ****         }
 272:Src/main.c    ****       #endif
 273:Src/main.c    **** 
 274:Src/main.c    ****       // ####### MIXER #######
 275:Src/main.c    ****       // speedR = CLAMP((int)(speed * SPEED_COEFFICIENT -  steer * STEER_COEFFICIENT), INPUT_MIN, I
 276:Src/main.c    ****       // speedL = CLAMP((int)(speed * SPEED_COEFFICIENT +  steer * STEER_COEFFICIENT), INPUT_MIN, I
 277:Src/main.c    ****       mixerFcn(speed << 4, steer << 4, &speedR, &speedL);   // This function implements the equatio
 278:Src/main.c    **** 
 279:Src/main.c    ****       // ####### SET OUTPUTS (if the target change is less than +/- 100) #######
 280:Src/main.c    ****       if ((speedL > lastSpeedL-100 && speedL < lastSpeedL+100) && (speedR > lastSpeedR-100 && speed
 281:Src/main.c    ****         #ifdef INVERT_R_DIRECTION
 282:Src/main.c    ****           pwmr = speedR;
 283:Src/main.c    ****         #else
 284:Src/main.c    ****           pwmr = -speedR;
 285:Src/main.c    ****         #endif
 286:Src/main.c    ****         #ifdef INVERT_L_DIRECTION
 287:Src/main.c    ****           pwml = -speedL;
 288:Src/main.c    ****         #else
 289:Src/main.c    ****           pwml = speedL;
 290:Src/main.c    ****         #endif
 291:Src/main.c    ****       }
 292:Src/main.c    ****     #endif
 293:Src/main.c    **** 
 294:Src/main.c    ****     #ifdef VARIANT_TRANSPOTTER
 295:Src/main.c    ****       distance    = CLAMP(cmd1 - 180, 0, 4095);
 296:Src/main.c    ****       steering    = (cmd2 - 2048) / 2048.0;
 297:Src/main.c    ****       distanceErr = distance - (int)(setDistance * 1345);
 298:Src/main.c    **** 
 299:Src/main.c    ****       if (nunchuk_connected == 0) {
 300:Src/main.c    ****         speedL = speedL * 0.8f + (CLAMP(distanceErr + (steering*((float)MAX(ABS(distanceErr), 50)) 
 301:Src/main.c    ****         speedR = speedR * 0.8f + (CLAMP(distanceErr - (steering*((float)MAX(ABS(distanceErr), 50)) 
 302:Src/main.c    ****         if ((speedL < lastSpeedL + 50 && speedL > lastSpeedL - 50) && (speedR < lastSpeedR + 50 && 
 303:Src/main.c    ****           if (distanceErr > 0) {
 304:Src/main.c    ****             enable = 1;
 305:Src/main.c    ****           }
 306:Src/main.c    ****           if (distanceErr > -300) {
 307:Src/main.c    ****             #ifdef INVERT_R_DIRECTION
 308:Src/main.c    ****               pwmr = speedR;
 309:Src/main.c    ****             #else
 310:Src/main.c    ****               pwmr = -speedR;
 311:Src/main.c    ****             #endif
 312:Src/main.c    ****             #ifdef INVERT_L_DIRECTION
 313:Src/main.c    ****               pwml = -speedL;
 314:Src/main.c    ****             #else
 315:Src/main.c    ****               pwml = speedL;
 316:Src/main.c    ****             #endif
 317:Src/main.c    **** 
 318:Src/main.c    ****             if (checkRemote) {
ARM GAS  /tmp/ccwN6eMm.s 			page 7


 319:Src/main.c    ****               if (!HAL_GPIO_ReadPin(LED_PORT, LED_PIN)) {
 320:Src/main.c    ****                 //enable = 1;
 321:Src/main.c    ****               } else {
 322:Src/main.c    ****                 enable = 0;
 323:Src/main.c    ****               }
 324:Src/main.c    ****             }
 325:Src/main.c    ****           } else {
 326:Src/main.c    ****             enable = 0;
 327:Src/main.c    ****           }
 328:Src/main.c    ****         }
 329:Src/main.c    ****         timeoutCnt = 0;
 330:Src/main.c    ****       }
 331:Src/main.c    **** 
 332:Src/main.c    ****       if (timeoutCnt > TIMEOUT) {
 333:Src/main.c    ****         pwml = 0;
 334:Src/main.c    ****         pwmr = 0;
 335:Src/main.c    ****         enable = 0;
 336:Src/main.c    ****         #ifdef SUPPORT_LCD
 337:Src/main.c    ****           LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 338:Src/main.c    ****           LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 339:Src/main.c    ****           LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 340:Src/main.c    ****         #endif
 341:Src/main.c    ****         HAL_Delay(1000);
 342:Src/main.c    ****         nunchuk_connected = 0;
 343:Src/main.c    ****       }
 344:Src/main.c    **** 
 345:Src/main.c    ****       if ((distance / 1345.0) - setDistance > 0.5 && (lastDistance / 1345.0) - setDistance > 0.5) {
 346:Src/main.c    ****         enable = 0;
 347:Src/main.c    ****         longBeep(5);
 348:Src/main.c    ****         #ifdef SUPPORT_LCD
 349:Src/main.c    ****           LCD_ClearDisplay(&lcd);
 350:Src/main.c    ****           HAL_Delay(5);
 351:Src/main.c    ****           LCD_SetLocation(&lcd, 0, 0); LCD_WriteString(&lcd, "Emergency Off!");
 352:Src/main.c    ****           LCD_SetLocation(&lcd, 0, 1); LCD_WriteString(&lcd, "Keeper too fast.");
 353:Src/main.c    ****         #endif
 354:Src/main.c    ****         poweroff();
 355:Src/main.c    ****       }
 356:Src/main.c    **** 
 357:Src/main.c    ****       #ifdef SUPPORT_NUNCHUK
 358:Src/main.c    ****         if (transpotter_counter % 500 == 0) {
 359:Src/main.c    ****           if (nunchuk_connected == 0 && enable == 0) {
 360:Src/main.c    ****             if (Nunchuk_Ping()) {
 361:Src/main.c    ****               HAL_Delay(500);
 362:Src/main.c    ****               Nunchuk_Init();
 363:Src/main.c    ****               #ifdef SUPPORT_LCD
 364:Src/main.c    ****                 LCD_SetLocation(&lcd, 0, 0); LCD_WriteString(&lcd, "Nunchuk Control");
 365:Src/main.c    ****               #endif
 366:Src/main.c    ****               timeoutCnt = 0;
 367:Src/main.c    ****               HAL_Delay(1000);
 368:Src/main.c    ****               nunchuk_connected = 1;
 369:Src/main.c    ****             }
 370:Src/main.c    ****           }
 371:Src/main.c    ****         }   
 372:Src/main.c    ****       #endif
 373:Src/main.c    **** 
 374:Src/main.c    ****       #ifdef SUPPORT_LCD
 375:Src/main.c    ****         if (transpotter_counter % 100 == 0) {
ARM GAS  /tmp/ccwN6eMm.s 			page 8


 376:Src/main.c    ****           if (LCDerrorFlag == 1 && enable == 0) {
 377:Src/main.c    **** 
 378:Src/main.c    ****           } else {
 379:Src/main.c    ****             if (nunchuk_connected == 0) {
 380:Src/main.c    ****               LCD_SetLocation(&lcd,  4, 0); LCD_WriteFloat(&lcd,distance/1345.0,2);
 381:Src/main.c    ****               LCD_SetLocation(&lcd, 10, 0); LCD_WriteFloat(&lcd,setDistance,2);
 382:Src/main.c    ****             }
 383:Src/main.c    ****             LCD_SetLocation(&lcd,  4, 1); LCD_WriteFloat(&lcd,batVoltage, 1);
 384:Src/main.c    ****             // LCD_SetLocation(&lcd, 11, 1); LCD_WriteFloat(&lcd,MAX(ABS(currentR), ABS(currentL)),
 385:Src/main.c    ****           }
 386:Src/main.c    ****         }
 387:Src/main.c    ****       #endif
 388:Src/main.c    ****       transpotter_counter++;
 389:Src/main.c    ****     #endif
 390:Src/main.c    **** 
 391:Src/main.c    ****     // ####### SIDEBOARDS HANDLING #######
 392:Src/main.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 393:Src/main.c    ****       sideboardLeds(&sideboard_leds_L);
 394:Src/main.c    ****       sideboardSensors((uint8_t)Sideboard_L.sensors);
 395:Src/main.c    ****     #endif
 396:Src/main.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
 397:Src/main.c    ****       sideboardLeds(&sideboard_leds_R);
 398:Src/main.c    ****       sideboardSensors((uint8_t)Sideboard_R.sensors);
 399:Src/main.c    ****     #endif
 400:Src/main.c    **** 
 401:Src/main.c    ****     // ####### CALC BOARD TEMPERATURE #######
 402:Src/main.c    ****     filtLowPass32(adc_buffer.temp, TEMP_FILT_COEF, &board_temp_adcFixdt);
 403:Src/main.c    ****     board_temp_adcFilt  = (int16_t)(board_temp_adcFixdt >> 16);  // convert fixed-point to integer
 404:Src/main.c    ****     board_temp_deg_c    = (TEMP_CAL_HIGH_DEG_C - TEMP_CAL_LOW_DEG_C) * (board_temp_adcFilt - TEMP_C
 405:Src/main.c    **** 
 406:Src/main.c    ****     // ####### DEBUG SERIAL OUT #######
 407:Src/main.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 408:Src/main.c    ****       if (main_loop_counter % 25 == 0) {    // Send data periodically every 125 ms
 409:Src/main.c    ****         #ifdef CONTROL_ADC
 410:Src/main.c    ****         setScopeChannel(0, (int16_t)adc_buffer.l_tx2);          // 1: ADC1
 411:Src/main.c    ****         setScopeChannel(1, (int16_t)adc_buffer.l_rx2);          // 2: ADC2
 412:Src/main.c    ****         #endif
 413:Src/main.c    ****         #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 414:Src/main.c    ****         setScopeChannel(0, ppm_captured_value[0]);              // 1: CH1
 415:Src/main.c    ****         setScopeChannel(1, ppm_captured_value[1]);              // 2: CH2
 416:Src/main.c    ****         #endif
 417:Src/main.c    ****         #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 418:Src/main.c    ****         setScopeChannel(0, (pwm_captured_ch1_value - 500) * 2); // 1: CH1
 419:Src/main.c    ****         setScopeChannel(1, (pwm_captured_ch2_value - 500) * 2); // 2: CH2
 420:Src/main.c    ****         #endif
 421:Src/main.c    ****         setScopeChannel(2, (int16_t)speedR);                    // 3: output command: [-1000, 1000]
 422:Src/main.c    ****         setScopeChannel(3, (int16_t)speedL);                    // 4: output command: [-1000, 1000]
 423:Src/main.c    ****         setScopeChannel(4, (int16_t)adc_buffer.batt1);          // 5: for battery voltage calibrati
 424:Src/main.c    ****         setScopeChannel(5, (int16_t)(batVoltage * BAT_CALIB_REAL_VOLTAGE / BAT_CALIB_ADC)); // 6: f
 425:Src/main.c    ****         setScopeChannel(6, (int16_t)board_temp_adcFilt);        // 7: for board temperature calibra
 426:Src/main.c    ****         setScopeChannel(7, (int16_t)board_temp_deg_c);          // 8: for verifying board temperatu
 427:Src/main.c    ****         consoleScope();
 428:Src/main.c    ****       }
 429:Src/main.c    ****     #endif
 430:Src/main.c    **** 
 431:Src/main.c    ****     // ####### FEEDBACK SERIAL OUT #######
 432:Src/main.c    ****     #if defined(FEEDBACK_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USART3)
ARM GAS  /tmp/ccwN6eMm.s 			page 9


 433:Src/main.c    ****       if (main_loop_counter % 2 == 0) {    // Send data periodically every 10 ms
 434:Src/main.c    ****         Feedback.start	        = (uint16_t)SERIAL_START_FRAME;
 435:Src/main.c    ****         Feedback.cmd1           = (int16_t)cmd1;
 436:Src/main.c    ****         Feedback.cmd2           = (int16_t)cmd2;
 437:Src/main.c    ****         Feedback.speedR_meas	  = (int16_t)rtY_Right.n_mot;
 438:Src/main.c    ****         Feedback.speedL_meas	  = (int16_t)rtY_Left.n_mot;
 439:Src/main.c    ****         Feedback.batVoltage	    = (int16_t)(batVoltage * BAT_CALIB_REAL_VOLTAGE / BAT_CALIB_ADC);
 440:Src/main.c    ****         Feedback.boardTemp	    = (int16_t)board_temp_deg_c;
 441:Src/main.c    **** 
 442:Src/main.c    ****         #if defined(FEEDBACK_SERIAL_USART2)
 443:Src/main.c    ****           if(__HAL_DMA_GET_COUNTER(huart2.hdmatx) == 0) {
 444:Src/main.c    ****             Feedback.cmdLed         = (uint16_t)sideboard_leds_L;
 445:Src/main.c    ****             Feedback.checksum       = (uint16_t)(Feedback.start ^ Feedback.cmd1 ^ Feedback.cmd2 ^ F
 446:Src/main.c    ****                                                ^ Feedback.batVoltage ^ Feedback.boardTemp ^ Feedbac
 447:Src/main.c    **** 
 448:Src/main.c    ****             HAL_UART_Transmit_DMA(&huart2, (uint8_t *)&Feedback, sizeof(Feedback));
 449:Src/main.c    ****           }
 450:Src/main.c    ****         #endif
 451:Src/main.c    ****         #if defined(FEEDBACK_SERIAL_USART3)
 452:Src/main.c    ****           if(__HAL_DMA_GET_COUNTER(huart3.hdmatx) == 0) {
 453:Src/main.c    ****             Feedback.cmdLed         = (uint16_t)sideboard_leds_R;
 454:Src/main.c    ****             Feedback.checksum       = (uint16_t)(Feedback.start ^ Feedback.cmd1 ^ Feedback.cmd2 ^ F
 455:Src/main.c    ****                                                ^ Feedback.batVoltage ^ Feedback.boardTemp ^ Feedbac
 456:Src/main.c    **** 
 457:Src/main.c    ****             HAL_UART_Transmit_DMA(&huart3, (uint8_t *)&Feedback, sizeof(Feedback));
 458:Src/main.c    ****           }
 459:Src/main.c    ****         #endif            
 460:Src/main.c    ****       }
 461:Src/main.c    ****     #endif
 462:Src/main.c    **** 
 463:Src/main.c    ****     // ####### POWEROFF BY POWER-BUTTON #######
 464:Src/main.c    ****     poweroffPressCheck();
 465:Src/main.c    **** 
 466:Src/main.c    ****     // ####### BEEP AND EMERGENCY POWEROFF #######
 467:Src/main.c    ****     if ((TEMP_POWEROFF_ENABLE && board_temp_deg_c >= TEMP_POWEROFF && speedAvgAbs < 20) || (batVolt
 468:Src/main.c    ****       poweroff();
 469:Src/main.c    ****     } else if (rtY_Left.z_errCode || rtY_Right.z_errCode) {     // disable motors and beep in case 
 470:Src/main.c    ****       enable        = 0;
 471:Src/main.c    ****       buzzerFreq    = 8;
 472:Src/main.c    ****       buzzerPattern = 1;
 473:Src/main.c    ****     } else if (timeoutFlagADC || timeoutFlagSerial || timeoutCnt > TIMEOUT) { // beep in case of AD
 474:Src/main.c    ****       buzzerFreq    = 24;
 475:Src/main.c    ****       buzzerPattern = 1;
 476:Src/main.c    ****     } else if (TEMP_WARNING_ENABLE && board_temp_deg_c >= TEMP_WARNING) {  // beep if mainboard get
 477:Src/main.c    ****       buzzerFreq    = 4;
 478:Src/main.c    ****       buzzerPattern = 1;
 479:Src/main.c    ****     } else if (BAT_LVL1_ENABLE && batVoltage < BAT_LVL1) {      // low bat 1: fast beep
 480:Src/main.c    ****       buzzerFreq    = 5;
 481:Src/main.c    ****       buzzerPattern = 6;
 482:Src/main.c    ****     } else if (BAT_LVL2_ENABLE && batVoltage < BAT_LVL2) {      // low bat 2: slow beep
 483:Src/main.c    ****       buzzerFreq    = 5;
 484:Src/main.c    ****       buzzerPattern = 42;
 485:Src/main.c    ****     } else if (BEEPS_BACKWARD && ((speed < -50 && speedAvg < 0) || MultipleTapBrake.b_multipleTap))
 486:Src/main.c    ****       buzzerFreq    = 5;
 487:Src/main.c    ****       buzzerPattern = 1;
 488:Src/main.c    ****       backwardDrive = 1;
 489:Src/main.c    ****     } else {  // do not beep
ARM GAS  /tmp/ccwN6eMm.s 			page 10


 490:Src/main.c    ****       buzzerFreq    = 0;
 491:Src/main.c    ****       buzzerPattern = 0;
 492:Src/main.c    ****       backwardDrive = 0;
 493:Src/main.c    ****     }
 494:Src/main.c    **** 
 495:Src/main.c    **** 
 496:Src/main.c    ****     // ####### INACTIVITY TIMEOUT #######
 497:Src/main.c    ****     if (abs(speedL) > 50 || abs(speedR) > 50) {
 498:Src/main.c    ****       inactivity_timeout_counter = 0;
 499:Src/main.c    ****     } else {
 500:Src/main.c    ****       inactivity_timeout_counter++;
 501:Src/main.c    ****     }
 502:Src/main.c    ****     if (inactivity_timeout_counter > (INACTIVITY_TIMEOUT * 60 * 1000) / (DELAY_IN_MAIN_LOOP + 1)) {
 503:Src/main.c    ****       poweroff();
 504:Src/main.c    ****     }
 505:Src/main.c    **** 
 506:Src/main.c    ****     // HAL_GPIO_TogglePin(LED_PORT, LED_PIN);                 // This is to measure the main() loop
 507:Src/main.c    ****     // Update main loop states
 508:Src/main.c    ****     lastSpeedL = speedL;
 509:Src/main.c    ****     lastSpeedR = speedR;
 510:Src/main.c    ****     main_loop_counter++;
 511:Src/main.c    ****     timeoutCnt++;
 512:Src/main.c    ****   }
 513:Src/main.c    **** }
 514:Src/main.c    **** 
 515:Src/main.c    **** 
 516:Src/main.c    **** // ===========================================================
 517:Src/main.c    **** /** System Clock Configuration
 518:Src/main.c    **** */
 519:Src/main.c    **** void SystemClock_Config(void) {
  26              		.loc 1 519 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 88
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 30B5     		push	{r4, r5, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 12
  33              		.cfi_offset 4, -12
  34              		.cfi_offset 5, -8
  35              		.cfi_offset 14, -4
  36 0002 97B0     		sub	sp, sp, #92
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 104
 520:Src/main.c    ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 521:Src/main.c    ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 522:Src/main.c    ****   RCC_PeriphCLKInitTypeDef PeriphClkInit;
 523:Src/main.c    **** 
 524:Src/main.c    ****   /**Initializes the CPU, AHB and APB busses clocks
 525:Src/main.c    ****     */
 526:Src/main.c    ****   RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
  39              		.loc 1 526 0
  40 0004 0225     		movs	r5, #2
  41 0006 0C95     		str	r5, [sp, #48]
 527:Src/main.c    ****   RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
  42              		.loc 1 527 0
  43 0008 0123     		movs	r3, #1
  44 000a 1093     		str	r3, [sp, #64]
ARM GAS  /tmp/ccwN6eMm.s 			page 11


 528:Src/main.c    ****   RCC_OscInitStruct.HSICalibrationValue = 16;
  45              		.loc 1 528 0
  46 000c 1023     		movs	r3, #16
  47 000e 1193     		str	r3, [sp, #68]
 529:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
  48              		.loc 1 529 0
  49 0010 1395     		str	r5, [sp, #76]
 530:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI_DIV2;
  50              		.loc 1 530 0
  51 0012 0024     		movs	r4, #0
  52 0014 1494     		str	r4, [sp, #80]
 531:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL16;
  53              		.loc 1 531 0
  54 0016 4FF46013 		mov	r3, #3670016
  55 001a 1593     		str	r3, [sp, #84]
 532:Src/main.c    ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
  56              		.loc 1 532 0
  57 001c 0CA8     		add	r0, sp, #48
  58 001e FFF7FEFF 		bl	HAL_RCC_OscConfig
  59              	.LVL0:
 533:Src/main.c    **** 
 534:Src/main.c    ****   /**Initializes the CPU, AHB and APB busses clocks
 535:Src/main.c    ****     */
 536:Src/main.c    ****   RCC_ClkInitStruct.ClockType           = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE
  60              		.loc 1 536 0
  61 0022 0F23     		movs	r3, #15
  62 0024 0793     		str	r3, [sp, #28]
 537:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource        = RCC_SYSCLKSOURCE_PLLCLK;
  63              		.loc 1 537 0
  64 0026 0895     		str	r5, [sp, #32]
 538:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider       = RCC_SYSCLK_DIV1;
  65              		.loc 1 538 0
  66 0028 0994     		str	r4, [sp, #36]
 539:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider      = RCC_HCLK_DIV2;
  67              		.loc 1 539 0
  68 002a 4FF48063 		mov	r3, #1024
  69 002e 0A93     		str	r3, [sp, #40]
 540:Src/main.c    ****   RCC_ClkInitStruct.APB2CLKDivider      = RCC_HCLK_DIV1;
  70              		.loc 1 540 0
  71 0030 0B94     		str	r4, [sp, #44]
 541:Src/main.c    **** 
 542:Src/main.c    ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
  72              		.loc 1 542 0
  73 0032 2946     		mov	r1, r5
  74 0034 07A8     		add	r0, sp, #28
  75 0036 FFF7FEFF 		bl	HAL_RCC_ClockConfig
  76              	.LVL1:
 543:Src/main.c    **** 
 544:Src/main.c    ****   PeriphClkInit.PeriphClockSelection    = RCC_PERIPHCLK_ADC;
  77              		.loc 1 544 0
  78 003a 0195     		str	r5, [sp, #4]
 545:Src/main.c    ****   // PeriphClkInit.AdcClockSelection    = RCC_ADCPCLK2_DIV8;  // 8 MHz
 546:Src/main.c    ****   PeriphClkInit.AdcClockSelection       = RCC_ADCPCLK2_DIV4;  // 16 MHz
  79              		.loc 1 546 0
  80 003c 4FF48043 		mov	r3, #16384
  81 0040 0393     		str	r3, [sp, #12]
 547:Src/main.c    ****   HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
ARM GAS  /tmp/ccwN6eMm.s 			page 12


  82              		.loc 1 547 0
  83 0042 01A8     		add	r0, sp, #4
  84 0044 FFF7FEFF 		bl	HAL_RCCEx_PeriphCLKConfig
  85              	.LVL2:
 548:Src/main.c    **** 
 549:Src/main.c    ****   /**Configure the Systick interrupt time
 550:Src/main.c    ****     */
 551:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
  86              		.loc 1 551 0
  87 0048 FFF7FEFF 		bl	HAL_RCC_GetHCLKFreq
  88              	.LVL3:
  89 004c 084B     		ldr	r3, .L3
  90 004e A3FB0030 		umull	r3, r0, r3, r0
  91 0052 8009     		lsrs	r0, r0, #6
  92 0054 FFF7FEFF 		bl	HAL_SYSTICK_Config
  93              	.LVL4:
 552:Src/main.c    **** 
 553:Src/main.c    ****   /**Configure the Systick
 554:Src/main.c    ****     */
 555:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
  94              		.loc 1 555 0
  95 0058 0420     		movs	r0, #4
  96 005a FFF7FEFF 		bl	HAL_SYSTICK_CLKSourceConfig
  97              	.LVL5:
 556:Src/main.c    **** 
 557:Src/main.c    ****   /* SysTick_IRQn interrupt configuration */
 558:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
  98              		.loc 1 558 0
  99 005e 2246     		mov	r2, r4
 100 0060 2146     		mov	r1, r4
 101 0062 4FF0FF30 		mov	r0, #-1
 102 0066 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 103              	.LVL6:
 559:Src/main.c    **** }
 104              		.loc 1 559 0
 105 006a 17B0     		add	sp, sp, #92
 106              	.LCFI2:
 107              		.cfi_def_cfa_offset 12
 108              		@ sp needed
 109 006c 30BD     		pop	{r4, r5, pc}
 110              	.L4:
 111 006e 00BF     		.align	2
 112              	.L3:
 113 0070 D34D6210 		.word	274877907
 114              		.cfi_endproc
 115              	.LFE65:
 117              		.section	.text.main,"ax",%progbits
 118              		.align	1
 119              		.global	main
 120              		.syntax unified
 121              		.thumb
 122              		.thumb_func
 123              		.fpu softvfp
 125              	main:
 126              	.LFB64:
 152:Src/main.c    **** 
 127              		.loc 1 152 0
ARM GAS  /tmp/ccwN6eMm.s 			page 13


 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 16
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 132              	.LCFI3:
 133              		.cfi_def_cfa_offset 24
 134              		.cfi_offset 4, -24
 135              		.cfi_offset 5, -20
 136              		.cfi_offset 6, -16
 137              		.cfi_offset 7, -12
 138              		.cfi_offset 8, -8
 139              		.cfi_offset 14, -4
 140 0004 84B0     		sub	sp, sp, #16
 141              	.LCFI4:
 142              		.cfi_def_cfa_offset 40
 154:Src/main.c    ****   __HAL_RCC_AFIO_CLK_ENABLE();
 143              		.loc 1 154 0
 144 0006 FFF7FEFF 		bl	HAL_Init
 145              	.LVL7:
 146              	.LBB2:
 155:Src/main.c    ****   HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 147              		.loc 1 155 0
 148 000a C24C     		ldr	r4, .L25
 149 000c A369     		ldr	r3, [r4, #24]
 150 000e 43F00103 		orr	r3, r3, #1
 151 0012 A361     		str	r3, [r4, #24]
 152 0014 A369     		ldr	r3, [r4, #24]
 153 0016 03F00103 		and	r3, r3, #1
 154 001a 0193     		str	r3, [sp, #4]
 155 001c 019B     		ldr	r3, [sp, #4]
 156              	.LBE2:
 156:Src/main.c    ****   /* System interrupt init*/
 157              		.loc 1 156 0
 158 001e 0320     		movs	r0, #3
 159 0020 FFF7FEFF 		bl	HAL_NVIC_SetPriorityGrouping
 160              	.LVL8:
 159:Src/main.c    ****   /* BusFault_IRQn interrupt configuration */
 161              		.loc 1 159 0
 162 0024 0022     		movs	r2, #0
 163 0026 1146     		mov	r1, r2
 164 0028 6FF00B00 		mvn	r0, #11
 165 002c FFF7FEFF 		bl	HAL_NVIC_SetPriority
 166              	.LVL9:
 161:Src/main.c    ****   /* UsageFault_IRQn interrupt configuration */
 167              		.loc 1 161 0
 168 0030 0022     		movs	r2, #0
 169 0032 1146     		mov	r1, r2
 170 0034 6FF00A00 		mvn	r0, #10
 171 0038 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 172              	.LVL10:
 163:Src/main.c    ****   /* SVCall_IRQn interrupt configuration */
 173              		.loc 1 163 0
 174 003c 0022     		movs	r2, #0
 175 003e 1146     		mov	r1, r2
 176 0040 6FF00900 		mvn	r0, #9
 177 0044 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 178              	.LVL11:
ARM GAS  /tmp/ccwN6eMm.s 			page 14


 165:Src/main.c    ****   /* DebugMonitor_IRQn interrupt configuration */
 179              		.loc 1 165 0
 180 0048 0022     		movs	r2, #0
 181 004a 1146     		mov	r1, r2
 182 004c 6FF00400 		mvn	r0, #4
 183 0050 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 184              	.LVL12:
 167:Src/main.c    ****   /* PendSV_IRQn interrupt configuration */
 185              		.loc 1 167 0
 186 0054 0022     		movs	r2, #0
 187 0056 1146     		mov	r1, r2
 188 0058 6FF00300 		mvn	r0, #3
 189 005c FFF7FEFF 		bl	HAL_NVIC_SetPriority
 190              	.LVL13:
 169:Src/main.c    ****   /* SysTick_IRQn interrupt configuration */
 191              		.loc 1 169 0
 192 0060 0022     		movs	r2, #0
 193 0062 1146     		mov	r1, r2
 194 0064 6FF00100 		mvn	r0, #1
 195 0068 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 196              	.LVL14:
 171:Src/main.c    **** 
 197              		.loc 1 171 0
 198 006c 0022     		movs	r2, #0
 199 006e 1146     		mov	r1, r2
 200 0070 4FF0FF30 		mov	r0, #-1
 201 0074 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 202              	.LVL15:
 173:Src/main.c    **** 
 203              		.loc 1 173 0
 204 0078 FFF7FEFF 		bl	SystemClock_Config
 205              	.LVL16:
 175:Src/main.c    ****   MX_GPIO_Init();
 206              		.loc 1 175 0
 207 007c 6369     		ldr	r3, [r4, #20]
 208 007e 23F00103 		bic	r3, r3, #1
 209 0082 6361     		str	r3, [r4, #20]
 176:Src/main.c    ****   MX_TIM_Init();
 210              		.loc 1 176 0
 211 0084 FFF7FEFF 		bl	MX_GPIO_Init
 212              	.LVL17:
 177:Src/main.c    ****   MX_ADC1_Init();
 213              		.loc 1 177 0
 214 0088 FFF7FEFF 		bl	MX_TIM_Init
 215              	.LVL18:
 178:Src/main.c    ****   MX_ADC2_Init();
 216              		.loc 1 178 0
 217 008c FFF7FEFF 		bl	MX_ADC1_Init
 218              	.LVL19:
 179:Src/main.c    ****   BLDC_Init();        // BLDC Controller Init
 219              		.loc 1 179 0
 220 0090 FFF7FEFF 		bl	MX_ADC2_Init
 221              	.LVL20:
 180:Src/main.c    ****   Input_Lim_Init();   // Input Limitations Init
 222              		.loc 1 180 0
 223 0094 FFF7FEFF 		bl	BLDC_Init
 224              	.LVL21:
ARM GAS  /tmp/ccwN6eMm.s 			page 15


 181:Src/main.c    ****   Input_Init();       // Input Init
 225              		.loc 1 181 0
 226 0098 FFF7FEFF 		bl	Input_Lim_Init
 227              	.LVL22:
 182:Src/main.c    **** 
 228              		.loc 1 182 0
 229 009c FFF7FEFF 		bl	Input_Init
 230              	.LVL23:
 184:Src/main.c    **** 
 231              		.loc 1 184 0
 232 00a0 0122     		movs	r2, #1
 233 00a2 2021     		movs	r1, #32
 234 00a4 9C48     		ldr	r0, .L25+4
 235 00a6 FFF7FEFF 		bl	HAL_GPIO_WritePin
 236              	.LVL24:
 186:Src/main.c    ****   HAL_ADC_Start(&hadc2);  
 237              		.loc 1 186 0
 238 00aa 9C48     		ldr	r0, .L25+8
 239 00ac FFF7FEFF 		bl	HAL_ADC_Start
 240              	.LVL25:
 187:Src/main.c    **** 
 241              		.loc 1 187 0
 242 00b0 9B48     		ldr	r0, .L25+12
 243 00b2 FFF7FEFF 		bl	HAL_ADC_Start
 244              	.LVL26:
 189:Src/main.c    ****   HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET);
 245              		.loc 1 189 0
 246 00b6 FFF7FEFF 		bl	poweronMelody
 247              	.LVL27:
 190:Src/main.c    **** 
 248              		.loc 1 190 0
 249 00ba 0122     		movs	r2, #1
 250 00bc 0421     		movs	r1, #4
 251 00be 9948     		ldr	r0, .L25+16
 252 00c0 FFF7FEFF 		bl	HAL_GPIO_WritePin
 253              	.LVL28:
 192:Src/main.c    ****   int16_t lastSpeedL = 0, lastSpeedR = 0;
 254              		.loc 1 192 0
 255 00c4 0024     		movs	r4, #0
 256 00c6 ADF80E40 		strh	r4, [sp, #14]	@ movhi
 257 00ca ADF80C40 		strh	r4, [sp, #12]	@ movhi
 258              	.LVL29:
 195:Src/main.c    ****   int16_t board_temp_adcFilt  = adc_buffer.temp;
 259              		.loc 1 195 0
 260 00ce 964A     		ldr	r2, .L25+20
 261 00d0 138A     		ldrh	r3, [r2, #16]
 262 00d2 1B04     		lsls	r3, r3, #16
 263 00d4 0293     		str	r3, [sp, #8]
 196:Src/main.c    ****   int16_t board_temp_deg_c;
 264              		.loc 1 196 0
 265 00d6 138A     		ldrh	r3, [r2, #16]
 266              	.LVL30:
 193:Src/main.c    **** 
 267              		.loc 1 193 0
 268 00d8 2546     		mov	r5, r4
 269 00da D3E0     		b	.L20
 270              	.LVL31:
ARM GAS  /tmp/ccwN6eMm.s 			page 16


 271              	.L6:
 254:Src/main.c    ****       rateLimiter16(cmd2, RATE, &speedRateFixdt);
 272              		.loc 1 254 0
 273 00dc 934E     		ldr	r6, .L25+24
 274 00de 3246     		mov	r2, r6
 275 00e0 4FF4F071 		mov	r1, #480
 276 00e4 924B     		ldr	r3, .L25+28
 277 00e6 B3F90000 		ldrsh	r0, [r3]
 278 00ea FFF7FEFF 		bl	rateLimiter16
 279              	.LVL32:
 255:Src/main.c    ****       filtLowPass32(steerRateFixdt >> 4, FILTER, &steerFixdt);
 280              		.loc 1 255 0
 281 00ee DFF89C82 		ldr	r8, .L25+120
 282 00f2 4246     		mov	r2, r8
 283 00f4 4FF4F071 		mov	r1, #480
 284 00f8 8E4B     		ldr	r3, .L25+32
 285 00fa B3F90000 		ldrsh	r0, [r3]
 286 00fe FFF7FEFF 		bl	rateLimiter16
 287              	.LVL33:
 256:Src/main.c    ****       filtLowPass32(speedRateFixdt >> 4, FILTER, &speedFixdt);
 288              		.loc 1 256 0
 289 0102 8D4F     		ldr	r7, .L25+36
 290 0104 B6F90000 		ldrsh	r0, [r6]
 291 0108 3A46     		mov	r2, r7
 292 010a 41F69911 		movw	r1, #6553
 293 010e 0011     		asrs	r0, r0, #4
 294 0110 FFF7FEFF 		bl	filtLowPass32
 295              	.LVL34:
 257:Src/main.c    ****       steer = (int16_t)(steerFixdt >> 16);  // convert fixed-point to integer
 296              		.loc 1 257 0
 297 0114 894E     		ldr	r6, .L25+40
 298 0116 B8F90000 		ldrsh	r0, [r8]
 299 011a 3246     		mov	r2, r6
 300 011c 41F69911 		movw	r1, #6553
 301 0120 0011     		asrs	r0, r0, #4
 302 0122 FFF7FEFF 		bl	filtLowPass32
 303              	.LVL35:
 258:Src/main.c    ****       speed = (int16_t)(speedFixdt >> 16);  // convert fixed-point to integer
 304              		.loc 1 258 0
 305 0126 B7F90210 		ldrsh	r1, [r7, #2]
 259:Src/main.c    **** 
 306              		.loc 1 259 0
 307 012a B6F90200 		ldrsh	r0, [r6, #2]
 277:Src/main.c    **** 
 308              		.loc 1 277 0
 309 012e 0001     		lsls	r0, r0, #4
 310 0130 0901     		lsls	r1, r1, #4
 311 0132 0DF10E03 		add	r3, sp, #14
 312 0136 03AA     		add	r2, sp, #12
 313 0138 09B2     		sxth	r1, r1
 314 013a 00B2     		sxth	r0, r0
 315 013c FFF7FEFF 		bl	mixerFcn
 316              	.LVL36:
 280:Src/main.c    ****         #ifdef INVERT_R_DIRECTION
 317              		.loc 1 280 0
 318 0140 BDF90E30 		ldrsh	r3, [sp, #14]
 319 0144 A4F16402 		sub	r2, r4, #100
ARM GAS  /tmp/ccwN6eMm.s 			page 17


 320 0148 9342     		cmp	r3, r2
 321 014a 10DD     		ble	.L7
 280:Src/main.c    ****         #ifdef INVERT_R_DIRECTION
 322              		.loc 1 280 0 is_stmt 0 discriminator 1
 323 014c 6434     		adds	r4, r4, #100
 324              	.LVL37:
 325 014e A342     		cmp	r3, r4
 326 0150 0DDA     		bge	.L7
 280:Src/main.c    ****         #ifdef INVERT_R_DIRECTION
 327              		.loc 1 280 0 discriminator 2
 328 0152 BDF90C20 		ldrsh	r2, [sp, #12]
 329 0156 A5F16401 		sub	r1, r5, #100
 330 015a 8A42     		cmp	r2, r1
 331 015c 07DD     		ble	.L7
 280:Src/main.c    ****         #ifdef INVERT_R_DIRECTION
 332              		.loc 1 280 0 discriminator 3
 333 015e 6435     		adds	r5, r5, #100
 334              	.LVL38:
 335 0160 AA42     		cmp	r2, r5
 336 0162 04DA     		bge	.L7
 284:Src/main.c    ****         #endif
 337              		.loc 1 284 0 is_stmt 1
 338 0164 5242     		negs	r2, r2
 339 0166 7649     		ldr	r1, .L25+44
 340 0168 0A60     		str	r2, [r1]
 289:Src/main.c    ****         #endif
 341              		.loc 1 289 0
 342 016a 764A     		ldr	r2, .L25+48
 343 016c 1360     		str	r3, [r2]
 344              	.L7:
 402:Src/main.c    ****     board_temp_adcFilt  = (int16_t)(board_temp_adcFixdt >> 16);  // convert fixed-point to integer
 345              		.loc 1 402 0
 346 016e 6E4B     		ldr	r3, .L25+20
 347 0170 188A     		ldrh	r0, [r3, #16]
 348 0172 02AA     		add	r2, sp, #8
 349 0174 40F28F21 		movw	r1, #655
 350 0178 80B2     		uxth	r0, r0
 351 017a FFF7FEFF 		bl	filtLowPass32
 352              	.LVL39:
 403:Src/main.c    ****     board_temp_deg_c    = (TEMP_CAL_HIGH_DEG_C - TEMP_CAL_LOW_DEG_C) * (board_temp_adcFilt - TEMP_C
 353              		.loc 1 403 0
 354 017e BDF90A30 		ldrsh	r3, [sp, #10]
 355              	.LVL40:
 404:Src/main.c    **** 
 356              		.loc 1 404 0
 357 0182 A3F27763 		subw	r3, r3, #1655
 358              	.LVL41:
 359 0186 03EB8312 		add	r2, r3, r3, lsl #6
 360 018a 03EB4203 		add	r3, r3, r2, lsl #1
 361              	.LVL42:
 362 018e 6E4A     		ldr	r2, .L25+52
 363 0190 82FB0312 		smull	r1, r2, r2, r3
 364 0194 DB17     		asrs	r3, r3, #31
 365 0196 A3EB6203 		sub	r3, r3, r2, asr #1
 366 019a 03F5B373 		add	r3, r3, #358
 367 019e 1BB2     		sxth	r3, r3
 368              	.LVL43:
ARM GAS  /tmp/ccwN6eMm.s 			page 18


 433:Src/main.c    ****         Feedback.start	        = (uint16_t)SERIAL_START_FRAME;
 369              		.loc 1 433 0
 370 01a0 6A4A     		ldr	r2, .L25+56
 371 01a2 1268     		ldr	r2, [r2]
 372 01a4 12F0010F 		tst	r2, #1
 373 01a8 29D1     		bne	.L8
 434:Src/main.c    ****         Feedback.cmd1           = (int16_t)cmd1;
 374              		.loc 1 434 0
 375 01aa 6948     		ldr	r0, .L25+60
 376 01ac 4AF6CD32 		movw	r2, #43981
 377 01b0 0280     		strh	r2, [r0]	@ movhi
 435:Src/main.c    ****         Feedback.cmd2           = (int16_t)cmd2;
 378              		.loc 1 435 0
 379 01b2 5F4A     		ldr	r2, .L25+28
 380 01b4 B2F90070 		ldrsh	r7, [r2]
 381 01b8 4780     		strh	r7, [r0, #2]	@ movhi
 436:Src/main.c    ****         Feedback.speedR_meas	  = (int16_t)rtY_Right.n_mot;
 382              		.loc 1 436 0
 383 01ba 5E4A     		ldr	r2, .L25+32
 384 01bc B2F90060 		ldrsh	r6, [r2]
 385 01c0 8680     		strh	r6, [r0, #4]	@ movhi
 437:Src/main.c    ****         Feedback.speedL_meas	  = (int16_t)rtY_Left.n_mot;
 386              		.loc 1 437 0
 387 01c2 644A     		ldr	r2, .L25+64
 388 01c4 B2F90850 		ldrsh	r5, [r2, #8]
 389 01c8 C580     		strh	r5, [r0, #6]	@ movhi
 438:Src/main.c    ****         Feedback.batVoltage	    = (int16_t)(batVoltage * BAT_CALIB_REAL_VOLTAGE / BAT_CALIB_ADC);
 390              		.loc 1 438 0
 391 01ca 634A     		ldr	r2, .L25+68
 392 01cc B2F90840 		ldrsh	r4, [r2, #8]
 393 01d0 0481     		strh	r4, [r0, #8]	@ movhi
 439:Src/main.c    ****         Feedback.boardTemp	    = (int16_t)board_temp_deg_c;
 394              		.loc 1 439 0
 395 01d2 624A     		ldr	r2, .L25+72
 396 01d4 B2F90010 		ldrsh	r1, [r2]
 397 01d8 40F68272 		movw	r2, #3970
 398 01dc 02FB01F2 		mul	r2, r2, r1
 399 01e0 5F49     		ldr	r1, .L25+76
 400 01e2 81FB02E1 		smull	lr, r1, r1, r2
 401 01e6 D217     		asrs	r2, r2, #31
 402 01e8 C2EB6122 		rsb	r2, r2, r1, asr #9
 403 01ec 12B2     		sxth	r2, r2
 404 01ee 4281     		strh	r2, [r0, #10]	@ movhi
 440:Src/main.c    **** 
 405              		.loc 1 440 0
 406 01f0 8381     		strh	r3, [r0, #12]	@ movhi
 452:Src/main.c    ****             Feedback.cmdLed         = (uint16_t)sideboard_leds_R;
 407              		.loc 1 452 0
 408 01f2 5C49     		ldr	r1, .L25+80
 409 01f4 096B     		ldr	r1, [r1, #48]
 410 01f6 0968     		ldr	r1, [r1]
 411 01f8 4968     		ldr	r1, [r1, #4]
 412 01fa 0029     		cmp	r1, #0
 413 01fc 76D0     		beq	.L22
 414              	.LVL44:
 415              	.L8:
 464:Src/main.c    **** 
ARM GAS  /tmp/ccwN6eMm.s 			page 19


 416              		.loc 1 464 0
 417 01fe FFF7FEFF 		bl	poweroffPressCheck
 418              	.LVL45:
 467:Src/main.c    ****       poweroff();
 419              		.loc 1 467 0
 420 0202 564B     		ldr	r3, .L25+72
 421 0204 B3F90030 		ldrsh	r3, [r3]
 422 0208 40F2F142 		movw	r2, #1265
 423 020c 9342     		cmp	r3, r2
 424 020e 04DC     		bgt	.L9
 467:Src/main.c    ****       poweroff();
 425              		.loc 1 467 0 is_stmt 0 discriminator 1
 426 0210 554A     		ldr	r2, .L25+84
 427 0212 B2F90020 		ldrsh	r2, [r2]
 428 0216 132A     		cmp	r2, #19
 429 0218 78DD     		ble	.L23
 430              	.L9:
 469:Src/main.c    ****       enable        = 0;
 431              		.loc 1 469 0 is_stmt 1
 432 021a 4F4A     		ldr	r2, .L25+68
 433 021c 9279     		ldrb	r2, [r2, #6]	@ zero_extendqisi2
 434 021e 22B9     		cbnz	r2, .L11
 469:Src/main.c    ****       enable        = 0;
 435              		.loc 1 469 0 is_stmt 0 discriminator 1
 436 0220 4C4A     		ldr	r2, .L25+64
 437 0222 9279     		ldrb	r2, [r2, #6]	@ zero_extendqisi2
 438 0224 002A     		cmp	r2, #0
 439 0226 00F0B380 		beq	.L12
 440              	.L11:
 470:Src/main.c    ****       buzzerFreq    = 8;
 441              		.loc 1 470 0 is_stmt 1
 442 022a 0022     		movs	r2, #0
 443 022c 4F4B     		ldr	r3, .L25+88
 444 022e 1A70     		strb	r2, [r3]
 471:Src/main.c    ****       buzzerPattern = 1;
 445              		.loc 1 471 0
 446 0230 0822     		movs	r2, #8
 447 0232 4F4B     		ldr	r3, .L25+92
 448 0234 1A70     		strb	r2, [r3]
 472:Src/main.c    ****     } else if (timeoutFlagADC || timeoutFlagSerial || timeoutCnt > TIMEOUT) { // beep in case of AD
 449              		.loc 1 472 0
 450 0236 0122     		movs	r2, #1
 451 0238 4E4B     		ldr	r3, .L25+96
 452 023a 1A70     		strb	r2, [r3]
 453              	.L10:
 497:Src/main.c    ****       inactivity_timeout_counter = 0;
 454              		.loc 1 497 0
 455 023c BDF90E30 		ldrsh	r3, [sp, #14]
 456 0240 002B     		cmp	r3, #0
 457 0242 B8BF     		it	lt
 458 0244 5B42     		rsblt	r3, r3, #0
 459 0246 322B     		cmp	r3, #50
 460 0248 07DC     		bgt	.L16
 497:Src/main.c    ****       inactivity_timeout_counter = 0;
 461              		.loc 1 497 0 is_stmt 0 discriminator 1
 462 024a BDF90C30 		ldrsh	r3, [sp, #12]
 463 024e 002B     		cmp	r3, #0
ARM GAS  /tmp/ccwN6eMm.s 			page 20


 464 0250 B8BF     		it	lt
 465 0252 5B42     		rsblt	r3, r3, #0
 466 0254 322B     		cmp	r3, #50
 467 0256 40F3BF80 		ble	.L17
 468              	.L16:
 498:Src/main.c    ****     } else {
 469              		.loc 1 498 0 is_stmt 1
 470 025a 0022     		movs	r2, #0
 471 025c 464B     		ldr	r3, .L25+100
 472 025e 1A60     		str	r2, [r3]
 473              	.L18:
 502:Src/main.c    ****       poweroff();
 474              		.loc 1 502 0
 475 0260 454B     		ldr	r3, .L25+100
 476 0262 1A68     		ldr	r2, [r3]
 477 0264 454B     		ldr	r3, .L25+104
 478 0266 9A42     		cmp	r2, r3
 479 0268 00F2BB80 		bhi	.L24
 480              	.L19:
 508:Src/main.c    ****     lastSpeedR = speedR;
 481              		.loc 1 508 0
 482 026c BDF90E40 		ldrsh	r4, [sp, #14]
 483              	.LVL46:
 509:Src/main.c    ****     main_loop_counter++;
 484              		.loc 1 509 0
 485 0270 BDF90C50 		ldrsh	r5, [sp, #12]
 486              	.LVL47:
 510:Src/main.c    ****     timeoutCnt++;
 487              		.loc 1 510 0
 488 0274 354A     		ldr	r2, .L25+56
 489 0276 1368     		ldr	r3, [r2]
 490 0278 0133     		adds	r3, r3, #1
 491 027a 1360     		str	r3, [r2]
 511:Src/main.c    ****   }
 492              		.loc 1 511 0
 493 027c 404A     		ldr	r2, .L25+108
 494 027e 1368     		ldr	r3, [r2]
 495 0280 0133     		adds	r3, r3, #1
 496 0282 1360     		str	r3, [r2]
 497              	.LVL48:
 498              	.L20:
 201:Src/main.c    **** 
 499              		.loc 1 201 0
 500 0284 0520     		movs	r0, #5
 501 0286 FFF7FEFF 		bl	HAL_Delay
 502              	.LVL49:
 203:Src/main.c    ****     calcAvgSpeed();                       // Calculate average measured speed: speedAvg, speedAvgAb
 503              		.loc 1 203 0
 504 028a FFF7FEFF 		bl	readCommand
 505              	.LVL50:
 204:Src/main.c    **** 
 506              		.loc 1 204 0
 507 028e FFF7FEFF 		bl	calcAvgSpeed
 508              	.LVL51:
 208:Src/main.c    ****         shortBeep(6);                     // make 2 beeps indicating the motor enable
 509              		.loc 1 208 0
 510 0292 364B     		ldr	r3, .L25+88
ARM GAS  /tmp/ccwN6eMm.s 			page 21


 511 0294 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 512 0296 002B     		cmp	r3, #0
 513 0298 7FF420AF 		bne	.L6
 208:Src/main.c    ****         shortBeep(6);                     // make 2 beeps indicating the motor enable
 514              		.loc 1 208 0 is_stmt 0 discriminator 1
 515 029c 2E4B     		ldr	r3, .L25+68
 516 029e 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 517 02a0 002B     		cmp	r3, #0
 518 02a2 7FF41BAF 		bne	.L6
 208:Src/main.c    ****         shortBeep(6);                     // make 2 beeps indicating the motor enable
 519              		.loc 1 208 0 discriminator 2
 520 02a6 2B4B     		ldr	r3, .L25+64
 521 02a8 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 522 02aa 002B     		cmp	r3, #0
 523 02ac 7FF416AF 		bne	.L6
 208:Src/main.c    ****         shortBeep(6);                     // make 2 beeps indicating the motor enable
 524              		.loc 1 208 0 discriminator 3
 525 02b0 1F4B     		ldr	r3, .L25+28
 526 02b2 1B88     		ldrh	r3, [r3]
 527 02b4 3133     		adds	r3, r3, #49
 528 02b6 9BB2     		uxth	r3, r3
 529 02b8 622B     		cmp	r3, #98
 530 02ba 3FF60FAF 		bhi	.L6
 208:Src/main.c    ****         shortBeep(6);                     // make 2 beeps indicating the motor enable
 531              		.loc 1 208 0 discriminator 4
 532 02be 1D4B     		ldr	r3, .L25+32
 533 02c0 1B88     		ldrh	r3, [r3]
 534 02c2 3133     		adds	r3, r3, #49
 535 02c4 9BB2     		uxth	r3, r3
 536 02c6 622B     		cmp	r3, #98
 537 02c8 3FF608AF 		bhi	.L6
 209:Src/main.c    ****         shortBeep(4); HAL_Delay(100);
 538              		.loc 1 209 0 is_stmt 1
 539 02cc 0620     		movs	r0, #6
 540 02ce FFF7FEFF 		bl	shortBeep
 541              	.LVL52:
 210:Src/main.c    ****         enable = 1;                       // enable motors
 542              		.loc 1 210 0
 543 02d2 0420     		movs	r0, #4
 544 02d4 FFF7FEFF 		bl	shortBeep
 545              	.LVL53:
 546 02d8 6420     		movs	r0, #100
 547 02da FFF7FEFF 		bl	HAL_Delay
 548              	.LVL54:
 211:Src/main.c    ****         consoleLog("-- Motors enabled --\r\n");
 549              		.loc 1 211 0
 550 02de 0122     		movs	r2, #1
 551 02e0 224B     		ldr	r3, .L25+88
 552 02e2 1A70     		strb	r2, [r3]
 212:Src/main.c    ****       }
 553              		.loc 1 212 0
 554 02e4 2748     		ldr	r0, .L25+112
 555 02e6 FFF7FEFF 		bl	consoleLog
 556              	.LVL55:
 557 02ea F7E6     		b	.L6
 558              	.LVL56:
 559              	.L22:
ARM GAS  /tmp/ccwN6eMm.s 			page 22


 453:Src/main.c    ****             Feedback.checksum       = (uint16_t)(Feedback.start ^ Feedback.cmd1 ^ Feedback.cmd2 ^ F
 560              		.loc 1 453 0
 561 02ec 0146     		mov	r1, r0
 562 02ee 0020     		movs	r0, #0
 563 02f0 C881     		strh	r0, [r1, #14]	@ movhi
 454:Src/main.c    ****                                                ^ Feedback.batVoltage ^ Feedback.boardTemp ^ Feedbac
 564              		.loc 1 454 0
 565 02f2 2548     		ldr	r0, .L25+116
 566 02f4 7840     		eors	r0, r0, r7
 567 02f6 4640     		eors	r6, r6, r0
 568 02f8 7540     		eors	r5, r5, r6
 569 02fa 6C40     		eors	r4, r4, r5
 455:Src/main.c    **** 
 570              		.loc 1 455 0
 571 02fc 6240     		eors	r2, r2, r4
 572 02fe 5340     		eors	r3, r3, r2
 573              	.LVL57:
 454:Src/main.c    ****                                                ^ Feedback.batVoltage ^ Feedback.boardTemp ^ Feedbac
 574              		.loc 1 454 0
 575 0300 0B82     		strh	r3, [r1, #16]	@ movhi
 457:Src/main.c    ****           }
 576              		.loc 1 457 0
 577 0302 1222     		movs	r2, #18
 578 0304 1748     		ldr	r0, .L25+80
 579 0306 FFF7FEFF 		bl	HAL_UART_Transmit_DMA
 580              	.LVL58:
 581 030a 78E7     		b	.L8
 582              	.L23:
 468:Src/main.c    ****     } else if (rtY_Left.z_errCode || rtY_Right.z_errCode) {     // disable motors and beep in case 
 583              		.loc 1 468 0
 584 030c FFF7FEFF 		bl	poweroff
 585              	.LVL59:
 586 0310 94E7     		b	.L10
 587              	.L26:
 588 0312 00BF     		.align	2
 589              	.L25:
 590 0314 00100240 		.word	1073876992
 591 0318 00080140 		.word	1073809408
 592 031c 00000000 		.word	hadc1
 593 0320 00000000 		.word	hadc2
 594 0324 000C0140 		.word	1073810432
 595 0328 00000000 		.word	adc_buffer
 596 032c 00000000 		.word	.LANCHOR0
 597 0330 00000000 		.word	cmd1
 598 0334 00000000 		.word	cmd2
 599 0338 00000000 		.word	.LANCHOR2
 600 033c 00000000 		.word	.LANCHOR3
 601 0340 00000000 		.word	pwmr
 602 0344 00000000 		.word	pwml
 603 0348 6B4CA407 		.word	128207979
 604 034c 00000000 		.word	main_loop_counter
 605 0350 00000000 		.word	.LANCHOR4
 606 0354 00000000 		.word	rtY_Right
 607 0358 00000000 		.word	rtY_Left
 608 035c 00000000 		.word	batVoltage
 609 0360 D190D957 		.word	1473876177
 610 0364 00000000 		.word	huart3
ARM GAS  /tmp/ccwN6eMm.s 			page 23


 611 0368 00000000 		.word	speedAvgAbs
 612 036c 00000000 		.word	enable
 613 0370 00000000 		.word	buzzerFreq
 614 0374 00000000 		.word	buzzerPattern
 615 0378 00000000 		.word	.LANCHOR5
 616 037c 80380100 		.word	80000
 617 0380 00000000 		.word	timeoutCnt
 618 0384 00000000 		.word	.LC0
 619 0388 CDABFFFF 		.word	-21555
 620 038c 00000000 		.word	.LANCHOR1
 621              	.L12:
 473:Src/main.c    ****       buzzerFreq    = 24;
 622              		.loc 1 473 0
 623 0390 154A     		ldr	r2, .L27
 624 0392 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 625 0394 32B9     		cbnz	r2, .L13
 473:Src/main.c    ****       buzzerFreq    = 24;
 626              		.loc 1 473 0 is_stmt 0 discriminator 1
 627 0396 154A     		ldr	r2, .L27+4
 628 0398 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 629 039a 1AB9     		cbnz	r2, .L13
 473:Src/main.c    ****       buzzerFreq    = 24;
 630              		.loc 1 473 0 discriminator 2
 631 039c 144A     		ldr	r2, .L27+8
 632 039e 1268     		ldr	r2, [r2]
 633 03a0 142A     		cmp	r2, #20
 634 03a2 06D9     		bls	.L14
 635              	.L13:
 474:Src/main.c    ****       buzzerPattern = 1;
 636              		.loc 1 474 0 is_stmt 1
 637 03a4 1822     		movs	r2, #24
 638 03a6 134B     		ldr	r3, .L27+12
 639 03a8 1A70     		strb	r2, [r3]
 475:Src/main.c    ****     } else if (TEMP_WARNING_ENABLE && board_temp_deg_c >= TEMP_WARNING) {  // beep if mainboard get
 640              		.loc 1 475 0
 641 03aa 0122     		movs	r2, #1
 642 03ac 124B     		ldr	r3, .L27+16
 643 03ae 1A70     		strb	r2, [r3]
 644 03b0 44E7     		b	.L10
 645              	.L14:
 479:Src/main.c    ****       buzzerFreq    = 5;
 646              		.loc 1 479 0
 647 03b2 40F22252 		movw	r2, #1314
 648 03b6 9342     		cmp	r3, r2
 649 03b8 06DC     		bgt	.L15
 480:Src/main.c    ****       buzzerPattern = 6;
 650              		.loc 1 480 0
 651 03ba 0522     		movs	r2, #5
 652 03bc 0D4B     		ldr	r3, .L27+12
 653 03be 1A70     		strb	r2, [r3]
 481:Src/main.c    ****     } else if (BAT_LVL2_ENABLE && batVoltage < BAT_LVL2) {      // low bat 2: slow beep
 654              		.loc 1 481 0
 655 03c0 0622     		movs	r2, #6
 656 03c2 0D4B     		ldr	r3, .L27+16
 657 03c4 1A70     		strb	r2, [r3]
 658 03c6 39E7     		b	.L10
 659              	.L15:
ARM GAS  /tmp/ccwN6eMm.s 			page 24


 490:Src/main.c    ****       buzzerPattern = 0;
 660              		.loc 1 490 0
 661 03c8 0023     		movs	r3, #0
 662 03ca 0A4A     		ldr	r2, .L27+12
 663 03cc 1370     		strb	r3, [r2]
 491:Src/main.c    ****       backwardDrive = 0;
 664              		.loc 1 491 0
 665 03ce 0A4A     		ldr	r2, .L27+16
 666 03d0 1370     		strb	r3, [r2]
 492:Src/main.c    ****     }
 667              		.loc 1 492 0
 668 03d2 0A4A     		ldr	r2, .L27+20
 669 03d4 1370     		strb	r3, [r2]
 670 03d6 31E7     		b	.L10
 671              	.L17:
 500:Src/main.c    ****     }
 672              		.loc 1 500 0
 673 03d8 094A     		ldr	r2, .L27+24
 674 03da 1368     		ldr	r3, [r2]
 675 03dc 0133     		adds	r3, r3, #1
 676 03de 1360     		str	r3, [r2]
 677 03e0 3EE7     		b	.L18
 678              	.L24:
 503:Src/main.c    ****     }
 679              		.loc 1 503 0
 680 03e2 FFF7FEFF 		bl	poweroff
 681              	.LVL60:
 682 03e6 41E7     		b	.L19
 683              	.L28:
 684              		.align	2
 685              	.L27:
 686 03e8 00000000 		.word	timeoutFlagADC
 687 03ec 00000000 		.word	timeoutFlagSerial
 688 03f0 00000000 		.word	timeoutCnt
 689 03f4 00000000 		.word	buzzerFreq
 690 03f8 00000000 		.word	buzzerPattern
 691 03fc 00000000 		.word	backwardDrive
 692 0400 00000000 		.word	.LANCHOR5
 693              		.cfi_endproc
 694              	.LFE64:
 696              		.comm	main_loop_counter,4,4
 697              		.comm	backwardDrive,1,1
 698              		.section	.bss.Feedback,"aw",%nobits
 699              		.align	2
 700              		.set	.LANCHOR4,. + 0
 703              	Feedback:
 704 0000 00000000 		.space	18
 704      00000000 
 704      00000000 
 704      00000000 
 704      0000
 705              		.section	.bss.inactivity_timeout_counter,"aw",%nobits
 706              		.align	2
 707              		.set	.LANCHOR5,. + 0
 710              	inactivity_timeout_counter:
 711 0000 00000000 		.space	4
 712              		.section	.bss.speedFixdt,"aw",%nobits
ARM GAS  /tmp/ccwN6eMm.s 			page 25


 713              		.align	2
 714              		.set	.LANCHOR3,. + 0
 717              	speedFixdt:
 718 0000 00000000 		.space	4
 719              		.section	.bss.speedRateFixdt,"aw",%nobits
 720              		.align	1
 721              		.set	.LANCHOR1,. + 0
 724              	speedRateFixdt:
 725 0000 0000     		.space	2
 726              		.section	.bss.steerFixdt,"aw",%nobits
 727              		.align	2
 728              		.set	.LANCHOR2,. + 0
 731              	steerFixdt:
 732 0000 00000000 		.space	4
 733              		.section	.bss.steerRateFixdt,"aw",%nobits
 734              		.align	1
 735              		.set	.LANCHOR0,. + 0
 738              	steerRateFixdt:
 739 0000 0000     		.space	2
 740              		.section	.rodata.main.str1.4,"aMS",%progbits,1
 741              		.align	2
 742              	.LC0:
 743 0000 2D2D204D 		.ascii	"-- Motors enabled --\015\012\000"
 743      6F746F72 
 743      7320656E 
 743      61626C65 
 743      64202D2D 
 744              		.text
 745              	.Letext0:
 746              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 747              		.file 3 "/usr/include/newlib/sys/lock.h"
 748              		.file 4 "/usr/include/newlib/sys/_types.h"
 749              		.file 5 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 750              		.file 6 "/usr/include/newlib/sys/reent.h"
 751              		.file 7 "/usr/include/newlib/stdlib.h"
 752              		.file 8 "/usr/include/newlib/sys/_stdint.h"
 753              		.file 9 "Drivers/CMSIS/Include/core_cm3.h"
 754              		.file 10 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 755              		.file 11 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 756              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 757              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_rcc.h"
 758              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_rcc_ex.h"
 759              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 760              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 761              		.file 17 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_adc.h"
 762              		.file 18 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_tim.h"
 763              		.file 19 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 764              		.file 20 "Inc/defines.h"
 765              		.file 21 "Inc/util.h"
 766              		.file 22 "Inc/rtwtypes.h"
 767              		.file 23 "Inc/BLDC_controller.h"
 768              		.file 24 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_cortex.h"
 769              		.file 25 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 770              		.file 26 "Inc/setup.h"
 771              		.file 27 "Inc/comms.h"
ARM GAS  /tmp/ccwN6eMm.s 			page 26


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccwN6eMm.s:16     .text.SystemClock_Config:0000000000000000 $t
     /tmp/ccwN6eMm.s:23     .text.SystemClock_Config:0000000000000000 SystemClock_Config
     /tmp/ccwN6eMm.s:113    .text.SystemClock_Config:0000000000000070 $d
     /tmp/ccwN6eMm.s:118    .text.main:0000000000000000 $t
     /tmp/ccwN6eMm.s:125    .text.main:0000000000000000 main
     /tmp/ccwN6eMm.s:590    .text.main:0000000000000314 $d
                            *COM*:0000000000000004 main_loop_counter
     /tmp/ccwN6eMm.s:623    .text.main:0000000000000390 $t
     /tmp/ccwN6eMm.s:686    .text.main:00000000000003e8 $d
                            *COM*:0000000000000001 backwardDrive
     /tmp/ccwN6eMm.s:699    .bss.Feedback:0000000000000000 $d
     /tmp/ccwN6eMm.s:703    .bss.Feedback:0000000000000000 Feedback
     /tmp/ccwN6eMm.s:706    .bss.inactivity_timeout_counter:0000000000000000 $d
     /tmp/ccwN6eMm.s:710    .bss.inactivity_timeout_counter:0000000000000000 inactivity_timeout_counter
     /tmp/ccwN6eMm.s:713    .bss.speedFixdt:0000000000000000 $d
     /tmp/ccwN6eMm.s:717    .bss.speedFixdt:0000000000000000 speedFixdt
     /tmp/ccwN6eMm.s:720    .bss.speedRateFixdt:0000000000000000 $d
     /tmp/ccwN6eMm.s:724    .bss.speedRateFixdt:0000000000000000 speedRateFixdt
     /tmp/ccwN6eMm.s:727    .bss.steerFixdt:0000000000000000 $d
     /tmp/ccwN6eMm.s:731    .bss.steerFixdt:0000000000000000 steerFixdt
     /tmp/ccwN6eMm.s:734    .bss.steerRateFixdt:0000000000000000 $d
     /tmp/ccwN6eMm.s:738    .bss.steerRateFixdt:0000000000000000 steerRateFixdt
     /tmp/ccwN6eMm.s:741    .rodata.main.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_RCCEx_PeriphCLKConfig
HAL_RCC_GetHCLKFreq
HAL_SYSTICK_Config
HAL_SYSTICK_CLKSourceConfig
HAL_NVIC_SetPriority
HAL_Init
HAL_NVIC_SetPriorityGrouping
MX_GPIO_Init
MX_TIM_Init
MX_ADC1_Init
MX_ADC2_Init
BLDC_Init
Input_Lim_Init
Input_Init
HAL_GPIO_WritePin
HAL_ADC_Start
poweronMelody
rateLimiter16
filtLowPass32
mixerFcn
poweroffPressCheck
HAL_Delay
readCommand
calcAvgSpeed
shortBeep
consoleLog
HAL_UART_Transmit_DMA
ARM GAS  /tmp/ccwN6eMm.s 			page 27


poweroff
hadc1
hadc2
adc_buffer
cmd1
cmd2
pwmr
pwml
rtY_Right
rtY_Left
batVoltage
huart3
speedAvgAbs
enable
buzzerFreq
buzzerPattern
timeoutCnt
timeoutFlagADC
timeoutFlagSerial
