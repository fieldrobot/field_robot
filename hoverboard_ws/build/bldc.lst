ARM GAS  /tmp/ccXT4x7r.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"bldc.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.DMA1_Channel1_IRQHandler,"ax",%progbits
  16              		.align	1
  17              		.global	DMA1_Channel1_IRQHandler
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	DMA1_Channel1_IRQHandler:
  24              	.LFB64:
  25              		.file 1 "Src/bldc.c"
   1:Src/bldc.c    **** /*
   2:Src/bldc.c    **** * This file implements FOC motor control.
   3:Src/bldc.c    **** * This control method offers superior performanace
   4:Src/bldc.c    **** * compared to previous cummutation method. The new method features:
   5:Src/bldc.c    **** * ► reduced noise and vibrations
   6:Src/bldc.c    **** * ► smooth torque output
   7:Src/bldc.c    **** * ► improved motor efficiency -> lower energy consumption
   8:Src/bldc.c    **** *
   9:Src/bldc.c    **** * Copyright (C) 2019-2020 Emanuel FERU <aerdronix@gmail.com>
  10:Src/bldc.c    **** *
  11:Src/bldc.c    **** * This program is free software: you can redistribute it and/or modify
  12:Src/bldc.c    **** * it under the terms of the GNU General Public License as published by
  13:Src/bldc.c    **** * the Free Software Foundation, either version 3 of the License, or
  14:Src/bldc.c    **** * (at your option) any later version.
  15:Src/bldc.c    **** *
  16:Src/bldc.c    **** * This program is distributed in the hope that it will be useful,
  17:Src/bldc.c    **** * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18:Src/bldc.c    **** * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  19:Src/bldc.c    **** * GNU General Public License for more details.
  20:Src/bldc.c    **** *
  21:Src/bldc.c    **** * You should have received a copy of the GNU General Public License
  22:Src/bldc.c    **** * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  23:Src/bldc.c    **** */
  24:Src/bldc.c    **** 
  25:Src/bldc.c    **** #include "stm32f1xx_hal.h"
  26:Src/bldc.c    **** #include "defines.h"
  27:Src/bldc.c    **** #include "setup.h"
  28:Src/bldc.c    **** #include "config.h"
  29:Src/bldc.c    **** #include "util.h"
  30:Src/bldc.c    **** 
  31:Src/bldc.c    **** // Matlab includes and defines - from auto-code generation
  32:Src/bldc.c    **** // ###############################################################################
  33:Src/bldc.c    **** #include "BLDC_controller.h"           /* Model's header file */
ARM GAS  /tmp/ccXT4x7r.s 			page 2


  34:Src/bldc.c    **** #include "rtwtypes.h"
  35:Src/bldc.c    **** 
  36:Src/bldc.c    **** extern RT_MODEL *const rtM_Left;
  37:Src/bldc.c    **** extern RT_MODEL *const rtM_Right;
  38:Src/bldc.c    **** 
  39:Src/bldc.c    **** extern DW   rtDW_Left;                  /* Observable states */
  40:Src/bldc.c    **** extern ExtU rtU_Left;                   /* External inputs */
  41:Src/bldc.c    **** extern ExtY rtY_Left;                   /* External outputs */
  42:Src/bldc.c    **** 
  43:Src/bldc.c    **** extern DW   rtDW_Right;                 /* Observable states */
  44:Src/bldc.c    **** extern ExtU rtU_Right;                  /* External inputs */
  45:Src/bldc.c    **** extern ExtY rtY_Right;                  /* External outputs */
  46:Src/bldc.c    **** // ###############################################################################
  47:Src/bldc.c    **** 
  48:Src/bldc.c    **** static int16_t pwm_margin = 110;        /* This margin allows to always have a window in the PWM si
  49:Src/bldc.c    **** 
  50:Src/bldc.c    **** extern uint8_t ctrlModReq;
  51:Src/bldc.c    **** static int16_t curDC_max = (I_DC_MAX * A2BIT_CONV);
  52:Src/bldc.c    **** int16_t curL_phaA = 0, curL_phaB = 0, curL_DC = 0;
  53:Src/bldc.c    **** int16_t curR_phaB = 0, curR_phaC = 0, curR_DC = 0;
  54:Src/bldc.c    **** 
  55:Src/bldc.c    **** volatile int pwml = 0;
  56:Src/bldc.c    **** volatile int pwmr = 0;
  57:Src/bldc.c    **** 
  58:Src/bldc.c    **** extern volatile adc_buf_t adc_buffer;
  59:Src/bldc.c    **** 
  60:Src/bldc.c    **** uint8_t buzzerFreq          = 0;
  61:Src/bldc.c    **** uint8_t buzzerPattern       = 0;
  62:Src/bldc.c    **** static uint32_t buzzerTimer = 0;
  63:Src/bldc.c    **** 
  64:Src/bldc.c    **** uint8_t        enable       = 0;        // initially motors are disabled for SAFETY
  65:Src/bldc.c    **** static uint8_t enableFin    = 0;
  66:Src/bldc.c    **** 
  67:Src/bldc.c    **** static const uint16_t pwm_res  = 64000000 / 2 / PWM_FREQ; // = 2000
  68:Src/bldc.c    **** 
  69:Src/bldc.c    **** static uint16_t offsetcount = 0;
  70:Src/bldc.c    **** static int16_t offsetrlA    = 2000;
  71:Src/bldc.c    **** static int16_t offsetrlB    = 2000;
  72:Src/bldc.c    **** static int16_t offsetrrB    = 2000;
  73:Src/bldc.c    **** static int16_t offsetrrC    = 2000;
  74:Src/bldc.c    **** static int16_t offsetdcl    = 2000;
  75:Src/bldc.c    **** static int16_t offsetdcr    = 2000;
  76:Src/bldc.c    **** 
  77:Src/bldc.c    **** int16_t        batVoltage       = (400 * BAT_CELLS * BAT_CALIB_ADC) / BAT_CALIB_REAL_VOLTAGE;
  78:Src/bldc.c    **** static int32_t batVoltageFixdt  = (400 * BAT_CELLS * BAT_CALIB_ADC) / BAT_CALIB_REAL_VOLTAGE << 16;
  79:Src/bldc.c    **** 
  80:Src/bldc.c    **** // =================================
  81:Src/bldc.c    **** // DMA interrupt frequency =~ 16 kHz
  82:Src/bldc.c    **** // =================================
  83:Src/bldc.c    **** void DMA1_Channel1_IRQHandler(void) {
  26              		.loc 1 83 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  84:Src/bldc.c    **** 
  85:Src/bldc.c    ****   DMA1->IFCR = DMA_IFCR_CTCIF1;
  30              		.loc 1 85 0
ARM GAS  /tmp/ccXT4x7r.s 			page 3


  31 0000 0222     		movs	r2, #2
  32 0002 9E4B     		ldr	r3, .L40
  33 0004 5A60     		str	r2, [r3, #4]
  86:Src/bldc.c    ****   // HAL_GPIO_WritePin(LED_PORT, LED_PIN, 1);
  87:Src/bldc.c    ****   // HAL_GPIO_TogglePin(LED_PORT, LED_PIN);
  88:Src/bldc.c    **** 
  89:Src/bldc.c    ****   if(offsetcount < 2000) {  // calibrate ADC offsets
  34              		.loc 1 89 0
  35 0006 9E4B     		ldr	r3, .L40+4
  36 0008 1B88     		ldrh	r3, [r3]
  37 000a B3F5FA6F 		cmp	r3, #2000
  38 000e 7BD3     		bcc	.L38
  83:Src/bldc.c    **** 
  39              		.loc 1 83 0
  40 0010 10B5     		push	{r4, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 4, -8
  44              		.cfi_offset 14, -4
  90:Src/bldc.c    ****     offsetcount++;
  91:Src/bldc.c    ****     offsetrlA = (adc_buffer.rlA + offsetrlA) / 2;
  92:Src/bldc.c    ****     offsetrlB = (adc_buffer.rlB + offsetrlB) / 2;
  93:Src/bldc.c    ****     offsetrrB = (adc_buffer.rrB + offsetrrB) / 2;
  94:Src/bldc.c    ****     offsetrrC = (adc_buffer.rrC + offsetrrC) / 2;
  95:Src/bldc.c    ****     offsetdcl = (adc_buffer.dcl + offsetdcl) / 2;
  96:Src/bldc.c    ****     offsetdcr = (adc_buffer.dcr + offsetdcr) / 2;
  97:Src/bldc.c    ****     return;
  98:Src/bldc.c    ****   }
  99:Src/bldc.c    **** 
 100:Src/bldc.c    ****   if (buzzerTimer % 1000 == 0) {  // because you get float rounding errors if it would run every ti
  45              		.loc 1 100 0
  46 0012 9C4B     		ldr	r3, .L40+8
  47 0014 1A68     		ldr	r2, [r3]
  48 0016 9C4B     		ldr	r3, .L40+12
  49 0018 A3FB0213 		umull	r1, r3, r3, r2
  50 001c 9B09     		lsrs	r3, r3, #6
  51 001e 4FF47A71 		mov	r1, #1000
  52 0022 01FB1323 		mls	r3, r1, r3, r2
  53 0026 002B     		cmp	r3, #0
  54 0028 00F0AF80 		beq	.L39
  55              	.L4:
 101:Src/bldc.c    ****     filtLowPass32(adc_buffer.batt1, BAT_FILT_COEF, &batVoltageFixdt);
 102:Src/bldc.c    ****     batVoltage = (int16_t)(batVoltageFixdt >> 16);  // convert fixed-point to integer
 103:Src/bldc.c    ****   }
 104:Src/bldc.c    **** 
 105:Src/bldc.c    ****   // Get Left motor currents
 106:Src/bldc.c    ****   curL_phaA = (int16_t)(offsetrlA - adc_buffer.rlA);
  56              		.loc 1 106 0
  57 002c 974B     		ldr	r3, .L40+16
  58 002e 9A88     		ldrh	r2, [r3, #4]
  59 0030 91B2     		uxth	r1, r2
  60 0032 974A     		ldr	r2, .L40+20
  61 0034 1288     		ldrh	r2, [r2]
  62 0036 521A     		subs	r2, r2, r1
  63 0038 9649     		ldr	r1, .L40+24
  64 003a 0A80     		strh	r2, [r1]	@ movhi
 107:Src/bldc.c    ****   curL_phaB = (int16_t)(offsetrlB - adc_buffer.rlB);
ARM GAS  /tmp/ccXT4x7r.s 			page 4


  65              		.loc 1 107 0
  66 003c DA88     		ldrh	r2, [r3, #6]
  67 003e 91B2     		uxth	r1, r2
  68 0040 954A     		ldr	r2, .L40+28
  69 0042 1288     		ldrh	r2, [r2]
  70 0044 521A     		subs	r2, r2, r1
  71 0046 9549     		ldr	r1, .L40+32
  72 0048 0A80     		strh	r2, [r1]	@ movhi
 108:Src/bldc.c    ****   curL_DC   = (int16_t)(offsetdcl - adc_buffer.dcl);
  73              		.loc 1 108 0
  74 004a 5A88     		ldrh	r2, [r3, #2]
  75 004c 91B2     		uxth	r1, r2
  76 004e 944A     		ldr	r2, .L40+36
  77 0050 1288     		ldrh	r2, [r2]
  78 0052 521A     		subs	r2, r2, r1
  79 0054 12B2     		sxth	r2, r2
  80 0056 9349     		ldr	r1, .L40+40
  81 0058 0A80     		strh	r2, [r1]	@ movhi
 109:Src/bldc.c    ****   
 110:Src/bldc.c    ****   // Get Right motor currents
 111:Src/bldc.c    ****   curR_phaB = (int16_t)(offsetrrB - adc_buffer.rrB);
  82              		.loc 1 111 0
  83 005a 1989     		ldrh	r1, [r3, #8]
  84 005c 88B2     		uxth	r0, r1
  85 005e 9249     		ldr	r1, .L40+44
  86 0060 0988     		ldrh	r1, [r1]
  87 0062 091A     		subs	r1, r1, r0
  88 0064 9148     		ldr	r0, .L40+48
  89 0066 0180     		strh	r1, [r0]	@ movhi
 112:Src/bldc.c    ****   curR_phaC = (int16_t)(offsetrrC - adc_buffer.rrC);
  90              		.loc 1 112 0
  91 0068 5989     		ldrh	r1, [r3, #10]
  92 006a 88B2     		uxth	r0, r1
  93 006c 9049     		ldr	r1, .L40+52
  94 006e 0988     		ldrh	r1, [r1]
  95 0070 091A     		subs	r1, r1, r0
  96 0072 9048     		ldr	r0, .L40+56
  97 0074 0180     		strh	r1, [r0]	@ movhi
 113:Src/bldc.c    ****   curR_DC   = (int16_t)(offsetdcr - adc_buffer.dcr);
  98              		.loc 1 113 0
  99 0076 1B88     		ldrh	r3, [r3]
 100 0078 99B2     		uxth	r1, r3
 101 007a 8F4B     		ldr	r3, .L40+60
 102 007c 1B88     		ldrh	r3, [r3]
 103 007e 5B1A     		subs	r3, r3, r1
 104 0080 1BB2     		sxth	r3, r3
 105 0082 8E49     		ldr	r1, .L40+64
 106 0084 0B80     		strh	r3, [r1]	@ movhi
 114:Src/bldc.c    **** 
 115:Src/bldc.c    ****   // Disable PWM when current limit is reached (current chopping)
 116:Src/bldc.c    ****   // This is the Level 2 of current protection. The Level 1 should kick in first given by I_MOT_MAX
 117:Src/bldc.c    ****   if(ABS(curL_DC) > curDC_max || enable == 0) {
 107              		.loc 1 117 0
 108 0086 002A     		cmp	r2, #0
 109 0088 B8BF     		it	lt
 110 008a 5242     		rsblt	r2, r2, #0
 111 008c 40F25231 		movw	r1, #850
ARM GAS  /tmp/ccXT4x7r.s 			page 5


 112 0090 8A42     		cmp	r2, r1
 113 0092 04DC     		bgt	.L5
 114              		.loc 1 117 0 is_stmt 0 discriminator 1
 115 0094 8A4A     		ldr	r2, .L40+68
 116 0096 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 117 0098 002A     		cmp	r2, #0
 118 009a 40F08480 		bne	.L6
 119              	.L5:
 118:Src/bldc.c    ****     LEFT_TIM->BDTR &= ~TIM_BDTR_MOE;
 120              		.loc 1 118 0 is_stmt 1
 121 009e 8949     		ldr	r1, .L40+72
 122 00a0 4A6C     		ldr	r2, [r1, #68]
 123 00a2 22F40042 		bic	r2, r2, #32768
 124 00a6 4A64     		str	r2, [r1, #68]
 125              	.L7:
 119:Src/bldc.c    ****   } else {
 120:Src/bldc.c    ****     LEFT_TIM->BDTR |= TIM_BDTR_MOE;
 121:Src/bldc.c    ****   }
 122:Src/bldc.c    **** 
 123:Src/bldc.c    ****   if(ABS(curR_DC)  > curDC_max || enable == 0) {
 126              		.loc 1 123 0
 127 00a8 002B     		cmp	r3, #0
 128 00aa B8BF     		it	lt
 129 00ac 5B42     		rsblt	r3, r3, #0
 130 00ae 40F25232 		movw	r2, #850
 131 00b2 9342     		cmp	r3, r2
 132 00b4 03DC     		bgt	.L8
 133              		.loc 1 123 0 is_stmt 0 discriminator 1
 134 00b6 824B     		ldr	r3, .L40+68
 135 00b8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 136 00ba 002B     		cmp	r3, #0
 137 00bc 79D1     		bne	.L9
 138              	.L8:
 124:Src/bldc.c    ****     RIGHT_TIM->BDTR &= ~TIM_BDTR_MOE;
 139              		.loc 1 124 0 is_stmt 1
 140 00be 824A     		ldr	r2, .L40+76
 141 00c0 536C     		ldr	r3, [r2, #68]
 142 00c2 23F40043 		bic	r3, r3, #32768
 143 00c6 5364     		str	r3, [r2, #68]
 144              	.L10:
 125:Src/bldc.c    ****   } else {
 126:Src/bldc.c    ****     RIGHT_TIM->BDTR |= TIM_BDTR_MOE;
 127:Src/bldc.c    ****   }
 128:Src/bldc.c    **** 
 129:Src/bldc.c    ****   //create square wave for buzzer
 130:Src/bldc.c    ****   buzzerTimer++;
 145              		.loc 1 130 0
 146 00c8 6E4A     		ldr	r2, .L40+8
 147 00ca 1368     		ldr	r3, [r2]
 148 00cc 0133     		adds	r3, r3, #1
 149 00ce 1360     		str	r3, [r2]
 131:Src/bldc.c    ****   if (buzzerFreq != 0 && (buzzerTimer / 5000) % (buzzerPattern + 1) == 0) {
 150              		.loc 1 131 0
 151 00d0 7E4A     		ldr	r2, .L40+80
 152 00d2 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
 153 00d4 002C     		cmp	r4, #0
 154 00d6 72D0     		beq	.L11
ARM GAS  /tmp/ccXT4x7r.s 			page 6


 155              		.loc 1 131 0 is_stmt 0 discriminator 1
 156 00d8 7D4A     		ldr	r2, .L40+84
 157 00da A2FB0312 		umull	r1, r2, r2, r3
 158 00de 120B     		lsrs	r2, r2, #12
 159 00e0 7C49     		ldr	r1, .L40+88
 160 00e2 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 161 00e4 0131     		adds	r1, r1, #1
 162 00e6 B2FBF1F0 		udiv	r0, r2, r1
 163 00ea 01FB1022 		mls	r2, r1, r0, r2
 164 00ee 002A     		cmp	r2, #0
 165 00f0 65D1     		bne	.L11
 132:Src/bldc.c    ****     if (buzzerTimer % buzzerFreq == 0) {
 166              		.loc 1 132 0 is_stmt 1
 167 00f2 B3FBF4F2 		udiv	r2, r3, r4
 168 00f6 04FB1233 		mls	r3, r4, r2, r3
 169 00fa 002B     		cmp	r3, #0
 170 00fc 64D1     		bne	.L12
 133:Src/bldc.c    ****       HAL_GPIO_TogglePin(BUZZER_PORT, BUZZER_PIN);
 171              		.loc 1 133 0
 172 00fe 1021     		movs	r1, #16
 173 0100 7548     		ldr	r0, .L40+92
 174 0102 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 175              	.LVL0:
 176 0106 5FE0     		b	.L12
 177              	.L38:
 178              	.LCFI1:
 179              		.cfi_def_cfa_offset 0
 180              		.cfi_restore 4
 181              		.cfi_restore 14
  90:Src/bldc.c    ****     offsetrlA = (adc_buffer.rlA + offsetrlA) / 2;
 182              		.loc 1 90 0
 183 0108 0133     		adds	r3, r3, #1
 184 010a 5D4A     		ldr	r2, .L40+4
 185 010c 1380     		strh	r3, [r2]	@ movhi
  91:Src/bldc.c    ****     offsetrlB = (adc_buffer.rlB + offsetrlB) / 2;
 186              		.loc 1 91 0
 187 010e 5F4A     		ldr	r2, .L40+16
 188 0110 9388     		ldrh	r3, [r2, #4]
 189 0112 99B2     		uxth	r1, r3
 190 0114 5E48     		ldr	r0, .L40+20
 191 0116 B0F90030 		ldrsh	r3, [r0]
 192 011a 0B44     		add	r3, r3, r1
 193 011c 03EBD373 		add	r3, r3, r3, lsr #31
 194 0120 5B10     		asrs	r3, r3, #1
 195 0122 0380     		strh	r3, [r0]	@ movhi
  92:Src/bldc.c    ****     offsetrrB = (adc_buffer.rrB + offsetrrB) / 2;
 196              		.loc 1 92 0
 197 0124 D388     		ldrh	r3, [r2, #6]
 198 0126 99B2     		uxth	r1, r3
 199 0128 5B48     		ldr	r0, .L40+28
 200 012a B0F90030 		ldrsh	r3, [r0]
 201 012e 0B44     		add	r3, r3, r1
 202 0130 03EBD373 		add	r3, r3, r3, lsr #31
 203 0134 5B10     		asrs	r3, r3, #1
 204 0136 0380     		strh	r3, [r0]	@ movhi
  93:Src/bldc.c    ****     offsetrrC = (adc_buffer.rrC + offsetrrC) / 2;
 205              		.loc 1 93 0
ARM GAS  /tmp/ccXT4x7r.s 			page 7


 206 0138 1389     		ldrh	r3, [r2, #8]
 207 013a 99B2     		uxth	r1, r3
 208 013c 5A48     		ldr	r0, .L40+44
 209 013e B0F90030 		ldrsh	r3, [r0]
 210 0142 0B44     		add	r3, r3, r1
 211 0144 03EBD373 		add	r3, r3, r3, lsr #31
 212 0148 5B10     		asrs	r3, r3, #1
 213 014a 0380     		strh	r3, [r0]	@ movhi
  94:Src/bldc.c    ****     offsetdcl = (adc_buffer.dcl + offsetdcl) / 2;
 214              		.loc 1 94 0
 215 014c 5389     		ldrh	r3, [r2, #10]
 216 014e 99B2     		uxth	r1, r3
 217 0150 5748     		ldr	r0, .L40+52
 218 0152 B0F90030 		ldrsh	r3, [r0]
 219 0156 0B44     		add	r3, r3, r1
 220 0158 03EBD373 		add	r3, r3, r3, lsr #31
 221 015c 5B10     		asrs	r3, r3, #1
 222 015e 0380     		strh	r3, [r0]	@ movhi
  95:Src/bldc.c    ****     offsetdcr = (adc_buffer.dcr + offsetdcr) / 2;
 223              		.loc 1 95 0
 224 0160 5388     		ldrh	r3, [r2, #2]
 225 0162 99B2     		uxth	r1, r3
 226 0164 4E48     		ldr	r0, .L40+36
 227 0166 B0F90030 		ldrsh	r3, [r0]
 228 016a 0B44     		add	r3, r3, r1
 229 016c 03EBD373 		add	r3, r3, r3, lsr #31
 230 0170 5B10     		asrs	r3, r3, #1
 231 0172 0380     		strh	r3, [r0]	@ movhi
  96:Src/bldc.c    ****     return;
 232              		.loc 1 96 0
 233 0174 1388     		ldrh	r3, [r2]
 234 0176 9AB2     		uxth	r2, r3
 235 0178 4F49     		ldr	r1, .L40+60
 236 017a B1F90030 		ldrsh	r3, [r1]
 237 017e 1344     		add	r3, r3, r2
 238 0180 03EBD373 		add	r3, r3, r3, lsr #31
 239 0184 5B10     		asrs	r3, r3, #1
 240 0186 0B80     		strh	r3, [r1]	@ movhi
  97:Src/bldc.c    ****   }
 241              		.loc 1 97 0
 242 0188 7047     		bx	lr
 243              	.L39:
 244              	.LCFI2:
 245              		.cfi_def_cfa_offset 8
 246              		.cfi_offset 4, -8
 247              		.cfi_offset 14, -4
 101:Src/bldc.c    ****     batVoltage = (int16_t)(batVoltageFixdt >> 16);  // convert fixed-point to integer
 248              		.loc 1 101 0
 249 018a 404B     		ldr	r3, .L40+16
 250 018c 9889     		ldrh	r0, [r3, #12]
 251 018e 534C     		ldr	r4, .L40+96
 252 0190 2246     		mov	r2, r4
 253 0192 40F28F21 		movw	r1, #655
 254 0196 80B2     		uxth	r0, r0
 255 0198 FFF7FEFF 		bl	filtLowPass32
 256              	.LVL1:
 102:Src/bldc.c    ****   }
ARM GAS  /tmp/ccXT4x7r.s 			page 8


 257              		.loc 1 102 0
 258 019c B4F90220 		ldrsh	r2, [r4, #2]
 259 01a0 4F4B     		ldr	r3, .L40+100
 260 01a2 1A80     		strh	r2, [r3]	@ movhi
 261 01a4 42E7     		b	.L4
 262              	.L6:
 120:Src/bldc.c    ****   }
 263              		.loc 1 120 0
 264 01a6 4749     		ldr	r1, .L40+72
 265 01a8 4A6C     		ldr	r2, [r1, #68]
 266 01aa 42F40042 		orr	r2, r2, #32768
 267 01ae 4A64     		str	r2, [r1, #68]
 268 01b0 7AE7     		b	.L7
 269              	.L9:
 126:Src/bldc.c    ****   }
 270              		.loc 1 126 0
 271 01b2 454A     		ldr	r2, .L40+76
 272 01b4 536C     		ldr	r3, [r2, #68]
 273 01b6 43F40043 		orr	r3, r3, #32768
 274 01ba 5364     		str	r3, [r2, #68]
 275 01bc 84E7     		b	.L10
 276              	.L11:
 134:Src/bldc.c    ****     }
 135:Src/bldc.c    ****   } else {
 136:Src/bldc.c    ****       HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);
 277              		.loc 1 136 0
 278 01be 0022     		movs	r2, #0
 279 01c0 1021     		movs	r1, #16
 280 01c2 4548     		ldr	r0, .L40+92
 281 01c4 FFF7FEFF 		bl	HAL_GPIO_WritePin
 282              	.LVL2:
 283              	.L12:
 137:Src/bldc.c    ****   }
 138:Src/bldc.c    **** 
 139:Src/bldc.c    ****   // ############################### MOTOR CONTROL ###############################
 140:Src/bldc.c    **** 
 141:Src/bldc.c    ****   int ul, vl, wl;
 142:Src/bldc.c    ****   int ur, vr, wr;
 143:Src/bldc.c    ****   static boolean_T OverrunFlag = false;
 144:Src/bldc.c    **** 
 145:Src/bldc.c    ****   /* Check for overrun */
 146:Src/bldc.c    ****   if (OverrunFlag) {
 284              		.loc 1 146 0
 285 01c8 464B     		ldr	r3, .L40+104
 286 01ca 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 287 01cc 002B     		cmp	r3, #0
 288 01ce 40F02681 		bne	.L1
 147:Src/bldc.c    ****     return;
 148:Src/bldc.c    ****   }
 149:Src/bldc.c    ****   OverrunFlag = true;
 289              		.loc 1 149 0
 290 01d2 0122     		movs	r2, #1
 291 01d4 434B     		ldr	r3, .L40+104
 292 01d6 1A70     		strb	r2, [r3]
 150:Src/bldc.c    **** 
 151:Src/bldc.c    ****   /* Make sure to stop BOTH motors in case of an error */
 152:Src/bldc.c    ****   enableFin = enable && !rtY_Left.z_errCode && !rtY_Right.z_errCode;
ARM GAS  /tmp/ccXT4x7r.s 			page 9


 293              		.loc 1 152 0
 294 01d8 394B     		ldr	r3, .L40+68
 295 01da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 296 01dc 4BB1     		cbz	r3, .L20
 297              		.loc 1 152 0 is_stmt 0 discriminator 1
 298 01de 424B     		ldr	r3, .L40+108
 299 01e0 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 300 01e2 002B     		cmp	r3, #0
 301 01e4 45D1     		bne	.L21
 302              		.loc 1 152 0 discriminator 3
 303 01e6 414B     		ldr	r3, .L40+112
 304 01e8 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 305 01ea 002B     		cmp	r3, #0
 306 01ec 43D0     		beq	.L22
 307              		.loc 1 152 0
 308 01ee 0022     		movs	r2, #0
 309 01f0 00E0     		b	.L13
 310              	.L20:
 311 01f2 0022     		movs	r2, #0
 312              	.L13:
 313              		.loc 1 152 0 discriminator 8
 314 01f4 D2B2     		uxtb	r2, r2
 315 01f6 3E4B     		ldr	r3, .L40+116
 316 01f8 1A70     		strb	r2, [r3]
 153:Src/bldc.c    ****  
 154:Src/bldc.c    ****   // ========================= LEFT MOTOR ============================ 
 155:Src/bldc.c    ****     // Get hall sensors values
 156:Src/bldc.c    ****     uint8_t hall_ul = !(LEFT_HALL_U_PORT->IDR & LEFT_HALL_U_PIN);
 317              		.loc 1 156 0 is_stmt 1 discriminator 8
 318 01fa 3E4B     		ldr	r3, .L40+120
 319 01fc 9968     		ldr	r1, [r3, #8]
 320 01fe 11F0200F 		tst	r1, #32
 321 0202 0CBF     		ite	eq
 322 0204 0124     		moveq	r4, #1
 323 0206 0024     		movne	r4, #0
 324              	.LVL3:
 157:Src/bldc.c    ****     uint8_t hall_vl = !(LEFT_HALL_V_PORT->IDR & LEFT_HALL_V_PIN);
 325              		.loc 1 157 0 discriminator 8
 326 0208 9968     		ldr	r1, [r3, #8]
 327 020a 11F0400F 		tst	r1, #64
 328 020e 0CBF     		ite	eq
 329 0210 0120     		moveq	r0, #1
 330 0212 0020     		movne	r0, #0
 331              	.LVL4:
 158:Src/bldc.c    ****     uint8_t hall_wl = !(LEFT_HALL_W_PORT->IDR & LEFT_HALL_W_PIN);
 332              		.loc 1 158 0 discriminator 8
 333 0214 9B68     		ldr	r3, [r3, #8]
 334 0216 13F0800F 		tst	r3, #128
 335 021a 0CBF     		ite	eq
 336 021c 0121     		moveq	r1, #1
 337 021e 0021     		movne	r1, #0
 338              	.LVL5:
 159:Src/bldc.c    **** 
 160:Src/bldc.c    ****     /* Set motor inputs here */
 161:Src/bldc.c    ****     rtU_Left.b_motEna     = enableFin;
 339              		.loc 1 161 0 discriminator 8
 340 0220 354B     		ldr	r3, .L40+124
ARM GAS  /tmp/ccXT4x7r.s 			page 10


 341 0222 1A70     		strb	r2, [r3]
 162:Src/bldc.c    ****     rtU_Left.z_ctrlModReq = ctrlModReq;  
 342              		.loc 1 162 0 discriminator 8
 343 0224 354A     		ldr	r2, .L40+128
 344 0226 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 345 0228 5A70     		strb	r2, [r3, #1]
 163:Src/bldc.c    ****     rtU_Left.r_inpTgt     = pwml;
 346              		.loc 1 163 0 discriminator 8
 347 022a 354A     		ldr	r2, .L40+132
 348 022c 1268     		ldr	r2, [r2]
 349 022e 5A80     		strh	r2, [r3, #2]	@ movhi
 164:Src/bldc.c    ****     rtU_Left.b_hallA      = hall_ul;
 350              		.loc 1 164 0 discriminator 8
 351 0230 1C71     		strb	r4, [r3, #4]
 165:Src/bldc.c    ****     rtU_Left.b_hallB      = hall_vl;
 352              		.loc 1 165 0 discriminator 8
 353 0232 5871     		strb	r0, [r3, #5]
 166:Src/bldc.c    ****     rtU_Left.b_hallC      = hall_wl;
 354              		.loc 1 166 0 discriminator 8
 355 0234 9971     		strb	r1, [r3, #6]
 167:Src/bldc.c    ****     rtU_Left.i_phaAB      = curL_phaA;
 356              		.loc 1 167 0 discriminator 8
 357 0236 174A     		ldr	r2, .L40+24
 358 0238 1288     		ldrh	r2, [r2]
 359 023a 1A81     		strh	r2, [r3, #8]	@ movhi
 168:Src/bldc.c    ****     rtU_Left.i_phaBC      = curL_phaB;
 360              		.loc 1 168 0 discriminator 8
 361 023c 174A     		ldr	r2, .L40+32
 362 023e 1288     		ldrh	r2, [r2]
 363 0240 5A81     		strh	r2, [r3, #10]	@ movhi
 169:Src/bldc.c    ****     rtU_Left.i_DCLink     = curL_DC;    
 364              		.loc 1 169 0 discriminator 8
 365 0242 184A     		ldr	r2, .L40+40
 366 0244 1288     		ldrh	r2, [r2]
 367 0246 9A81     		strh	r2, [r3, #12]	@ movhi
 170:Src/bldc.c    ****     
 171:Src/bldc.c    ****     /* Step the controller */
 172:Src/bldc.c    ****     #ifdef MOTOR_LEFT_ENA    
 173:Src/bldc.c    ****     BLDC_controller_step(rtM_Left);
 368              		.loc 1 173 0 discriminator 8
 369 0248 2E4B     		ldr	r3, .L40+136
 370 024a 1868     		ldr	r0, [r3]
 371              	.LVL6:
 372 024c FFF7FEFF 		bl	BLDC_controller_step
 373              	.LVL7:
 174:Src/bldc.c    ****     #endif
 175:Src/bldc.c    **** 
 176:Src/bldc.c    ****     /* Get motor outputs here */
 177:Src/bldc.c    ****     ul            = rtY_Left.DC_phaA;
 374              		.loc 1 177 0 discriminator 8
 375 0250 254B     		ldr	r3, .L40+108
 376 0252 B3F90010 		ldrsh	r1, [r3]
 377              	.LVL8:
 178:Src/bldc.c    ****     vl            = rtY_Left.DC_phaB;
 378              		.loc 1 178 0 discriminator 8
 379 0256 B3F90220 		ldrsh	r2, [r3, #2]
 380              	.LVL9:
ARM GAS  /tmp/ccXT4x7r.s 			page 11


 179:Src/bldc.c    ****     wl            = rtY_Left.DC_phaC;
 381              		.loc 1 179 0 discriminator 8
 382 025a B3F90430 		ldrsh	r3, [r3, #4]
 383              	.LVL10:
 180:Src/bldc.c    ****   // errCodeLeft  = rtY_Left.z_errCode;
 181:Src/bldc.c    ****   // motSpeedLeft = rtY_Left.n_mot;
 182:Src/bldc.c    ****   // motAngleLeft = rtY_Left.a_elecAngle;
 183:Src/bldc.c    **** 
 184:Src/bldc.c    ****     /* Apply commands */
 185:Src/bldc.c    ****     LEFT_TIM->LEFT_TIM_U    = (uint16_t)CLAMP(ul + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 384              		.loc 1 185 0 discriminator 8
 385 025e 01F57A70 		add	r0, r1, #1000
 386 0262 40F26274 		movw	r4, #1890
 387              	.LVL11:
 388 0266 A042     		cmp	r0, r4
 389 0268 4EDC     		bgt	.L23
 390              		.loc 1 185 0 is_stmt 0 discriminator 2
 391 026a 6D28     		cmp	r0, #109
 392 026c 5ADD     		ble	.L24
 393              		.loc 1 185 0 discriminator 4
 394 026e 81B2     		uxth	r1, r0
 395              	.LVL12:
 396 0270 4CE0     		b	.L14
 397              	.LVL13:
 398              	.L21:
 152:Src/bldc.c    ****  
 399              		.loc 1 152 0 is_stmt 1
 400 0272 0022     		movs	r2, #0
 401 0274 BEE7     		b	.L13
 402              	.L22:
 403 0276 0122     		movs	r2, #1
 404 0278 BCE7     		b	.L13
 405              	.L41:
 406 027a 00BF     		.align	2
 407              	.L40:
 408 027c 00000240 		.word	1073872896
 409 0280 00000000 		.word	.LANCHOR0
 410 0284 00000000 		.word	.LANCHOR7
 411 0288 D34D6210 		.word	274877907
 412 028c 00000000 		.word	adc_buffer
 413 0290 00000000 		.word	.LANCHOR1
 414 0294 00000000 		.word	.LANCHOR10
 415 0298 00000000 		.word	.LANCHOR2
 416 029c 00000000 		.word	.LANCHOR11
 417 02a0 00000000 		.word	.LANCHOR5
 418 02a4 00000000 		.word	.LANCHOR12
 419 02a8 00000000 		.word	.LANCHOR3
 420 02ac 00000000 		.word	.LANCHOR13
 421 02b0 00000000 		.word	.LANCHOR4
 422 02b4 00000000 		.word	.LANCHOR14
 423 02b8 00000000 		.word	.LANCHOR6
 424 02bc 00000000 		.word	.LANCHOR15
 425 02c0 00000000 		.word	.LANCHOR16
 426 02c4 00340140 		.word	1073820672
 427 02c8 002C0140 		.word	1073818624
 428 02cc 00000000 		.word	.LANCHOR17
 429 02d0 5917B7D1 		.word	-776530087
ARM GAS  /tmp/ccXT4x7r.s 			page 12


 430 02d4 00000000 		.word	.LANCHOR18
 431 02d8 00080140 		.word	1073809408
 432 02dc 00000000 		.word	.LANCHOR8
 433 02e0 00000000 		.word	.LANCHOR9
 434 02e4 00000000 		.word	.LANCHOR19
 435 02e8 00000000 		.word	rtY_Left
 436 02ec 00000000 		.word	rtY_Right
 437 02f0 00000000 		.word	.LANCHOR20
 438 02f4 000C0140 		.word	1073810432
 439 02f8 00000000 		.word	rtU_Left
 440 02fc 00000000 		.word	ctrlModReq
 441 0300 00000000 		.word	.LANCHOR21
 442 0304 00000000 		.word	rtM_Left
 443              	.LVL14:
 444              	.L23:
 445              		.loc 1 185 0
 446 0308 40F26271 		movw	r1, #1890
 447              	.LVL15:
 448              	.L14:
 449              		.loc 1 185 0 is_stmt 0 discriminator 8
 450 030c 4548     		ldr	r0, .L42
 451              	.LVL16:
 452 030e 4163     		str	r1, [r0, #52]
 453              	.LVL17:
 186:Src/bldc.c    ****     LEFT_TIM->LEFT_TIM_V    = (uint16_t)CLAMP(vl + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 454              		.loc 1 186 0 is_stmt 1 discriminator 8
 455 0310 02F57A71 		add	r1, r2, #1000
 456 0314 40F26270 		movw	r0, #1890
 457 0318 8142     		cmp	r1, r0
 458 031a 05DC     		bgt	.L25
 459              		.loc 1 186 0 is_stmt 0 discriminator 2
 460 031c 6D29     		cmp	r1, #109
 461 031e 11DD     		ble	.L26
 462              		.loc 1 186 0 discriminator 4
 463 0320 8AB2     		uxth	r2, r1
 464              	.LVL18:
 465 0322 03E0     		b	.L15
 466              	.LVL19:
 467              	.L24:
 185:Src/bldc.c    ****     LEFT_TIM->LEFT_TIM_V    = (uint16_t)CLAMP(vl + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 468              		.loc 1 185 0 is_stmt 1
 469 0324 6E21     		movs	r1, #110
 470              	.LVL20:
 471 0326 F1E7     		b	.L14
 472              	.LVL21:
 473              	.L25:
 474              		.loc 1 186 0
 475 0328 40F26272 		movw	r2, #1890
 476              	.LVL22:
 477              	.L15:
 478              		.loc 1 186 0 is_stmt 0 discriminator 8
 479 032c 3D49     		ldr	r1, .L42
 480              	.LVL23:
 481 032e 8A63     		str	r2, [r1, #56]
 187:Src/bldc.c    ****     LEFT_TIM->LEFT_TIM_W    = (uint16_t)CLAMP(wl + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 482              		.loc 1 187 0 is_stmt 1 discriminator 8
 483 0330 03F57A72 		add	r2, r3, #1000
ARM GAS  /tmp/ccXT4x7r.s 			page 13


 484 0334 40F26271 		movw	r1, #1890
 485 0338 8A42     		cmp	r2, r1
 486 033a 05DC     		bgt	.L27
 487              		.loc 1 187 0 is_stmt 0 discriminator 2
 488 033c 6D2A     		cmp	r2, #109
 489 033e 45DD     		ble	.L28
 490              		.loc 1 187 0 discriminator 4
 491 0340 93B2     		uxth	r3, r2
 492              	.LVL24:
 493 0342 03E0     		b	.L16
 494              	.LVL25:
 495              	.L26:
 186:Src/bldc.c    ****     LEFT_TIM->LEFT_TIM_V    = (uint16_t)CLAMP(vl + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 496              		.loc 1 186 0 is_stmt 1
 497 0344 6E22     		movs	r2, #110
 498              	.LVL26:
 499 0346 F1E7     		b	.L15
 500              	.LVL27:
 501              	.L27:
 502              		.loc 1 187 0
 503 0348 40F26273 		movw	r3, #1890
 504              	.LVL28:
 505              	.L16:
 506              		.loc 1 187 0 is_stmt 0 discriminator 8
 507 034c 354A     		ldr	r2, .L42
 508              	.LVL29:
 509 034e D363     		str	r3, [r2, #60]
 188:Src/bldc.c    ****   // =================================================================
 189:Src/bldc.c    ****   
 190:Src/bldc.c    **** 
 191:Src/bldc.c    ****   // ========================= RIGHT MOTOR ===========================  
 192:Src/bldc.c    ****     // Get hall sensors values
 193:Src/bldc.c    ****     uint8_t hall_ur = !(RIGHT_HALL_U_PORT->IDR & RIGHT_HALL_U_PIN);
 510              		.loc 1 193 0 is_stmt 1 discriminator 8
 511 0350 354B     		ldr	r3, .L42+4
 512 0352 9A68     		ldr	r2, [r3, #8]
 513 0354 12F4806F 		tst	r2, #1024
 514 0358 0CBF     		ite	eq
 515 035a 0120     		moveq	r0, #1
 516 035c 0020     		movne	r0, #0
 517              	.LVL30:
 194:Src/bldc.c    ****     uint8_t hall_vr = !(RIGHT_HALL_V_PORT->IDR & RIGHT_HALL_V_PIN);
 518              		.loc 1 194 0 discriminator 8
 519 035e 9A68     		ldr	r2, [r3, #8]
 520 0360 12F4006F 		tst	r2, #2048
 521 0364 0CBF     		ite	eq
 522 0366 0121     		moveq	r1, #1
 523 0368 0021     		movne	r1, #0
 524              	.LVL31:
 195:Src/bldc.c    ****     uint8_t hall_wr = !(RIGHT_HALL_W_PORT->IDR & RIGHT_HALL_W_PIN);
 525              		.loc 1 195 0 discriminator 8
 526 036a 9B68     		ldr	r3, [r3, #8]
 527 036c 13F4805F 		tst	r3, #4096
 528 0370 0CBF     		ite	eq
 529 0372 0122     		moveq	r2, #1
 530 0374 0022     		movne	r2, #0
 531              	.LVL32:
ARM GAS  /tmp/ccXT4x7r.s 			page 14


 196:Src/bldc.c    **** 
 197:Src/bldc.c    ****     /* Set motor inputs here */
 198:Src/bldc.c    ****     rtU_Right.b_motEna      = enableFin;
 532              		.loc 1 198 0 discriminator 8
 533 0376 2D4B     		ldr	r3, .L42+8
 534 0378 2D4C     		ldr	r4, .L42+12
 535 037a 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
 536 037c 1C70     		strb	r4, [r3]
 199:Src/bldc.c    ****     rtU_Right.z_ctrlModReq  = ctrlModReq;
 537              		.loc 1 199 0 discriminator 8
 538 037e 2D4C     		ldr	r4, .L42+16
 539 0380 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
 540 0382 5C70     		strb	r4, [r3, #1]
 200:Src/bldc.c    ****     rtU_Right.r_inpTgt      = pwmr;
 541              		.loc 1 200 0 discriminator 8
 542 0384 2C4C     		ldr	r4, .L42+20
 543 0386 2468     		ldr	r4, [r4]
 544 0388 5C80     		strh	r4, [r3, #2]	@ movhi
 201:Src/bldc.c    ****     rtU_Right.b_hallA       = hall_ur;
 545              		.loc 1 201 0 discriminator 8
 546 038a 1871     		strb	r0, [r3, #4]
 202:Src/bldc.c    ****     rtU_Right.b_hallB       = hall_vr;
 547              		.loc 1 202 0 discriminator 8
 548 038c 5971     		strb	r1, [r3, #5]
 203:Src/bldc.c    ****     rtU_Right.b_hallC       = hall_wr;
 549              		.loc 1 203 0 discriminator 8
 550 038e 9A71     		strb	r2, [r3, #6]
 204:Src/bldc.c    ****     rtU_Right.i_phaAB       = curR_phaB;
 551              		.loc 1 204 0 discriminator 8
 552 0390 2A4A     		ldr	r2, .L42+24
 553              	.LVL33:
 554 0392 1288     		ldrh	r2, [r2]
 555 0394 1A81     		strh	r2, [r3, #8]	@ movhi
 205:Src/bldc.c    ****     rtU_Right.i_phaBC       = curR_phaC;
 556              		.loc 1 205 0 discriminator 8
 557 0396 2A4A     		ldr	r2, .L42+28
 558 0398 1288     		ldrh	r2, [r2]
 559 039a 5A81     		strh	r2, [r3, #10]	@ movhi
 206:Src/bldc.c    ****     rtU_Right.i_DCLink      = curR_DC;
 560              		.loc 1 206 0 discriminator 8
 561 039c 294A     		ldr	r2, .L42+32
 562 039e 1288     		ldrh	r2, [r2]
 563 03a0 9A81     		strh	r2, [r3, #12]	@ movhi
 207:Src/bldc.c    **** 
 208:Src/bldc.c    ****     /* Step the controller */
 209:Src/bldc.c    ****     #ifdef MOTOR_RIGHT_ENA
 210:Src/bldc.c    ****     BLDC_controller_step(rtM_Right);
 564              		.loc 1 210 0 discriminator 8
 565 03a2 294B     		ldr	r3, .L42+36
 566              	.LVL34:
 567 03a4 1868     		ldr	r0, [r3]
 568              	.LVL35:
 569 03a6 FFF7FEFF 		bl	BLDC_controller_step
 570              	.LVL36:
 211:Src/bldc.c    ****     #endif
 212:Src/bldc.c    **** 
 213:Src/bldc.c    ****     /* Get motor outputs here */
ARM GAS  /tmp/ccXT4x7r.s 			page 15


 214:Src/bldc.c    ****     ur            = rtY_Right.DC_phaA;
 571              		.loc 1 214 0 discriminator 8
 572 03aa 284B     		ldr	r3, .L42+40
 573 03ac B3F90010 		ldrsh	r1, [r3]
 574              	.LVL37:
 215:Src/bldc.c    ****     vr            = rtY_Right.DC_phaB;
 575              		.loc 1 215 0 discriminator 8
 576 03b0 B3F90220 		ldrsh	r2, [r3, #2]
 577              	.LVL38:
 216:Src/bldc.c    ****     wr            = rtY_Right.DC_phaC;
 578              		.loc 1 216 0 discriminator 8
 579 03b4 B3F90430 		ldrsh	r3, [r3, #4]
 580              	.LVL39:
 217:Src/bldc.c    ****  // errCodeRight  = rtY_Right.z_errCode;
 218:Src/bldc.c    ****  // motSpeedRight = rtY_Right.n_mot;
 219:Src/bldc.c    ****  // motAngleRight = rtY_Right.a_elecAngle;
 220:Src/bldc.c    **** 
 221:Src/bldc.c    ****     /* Apply commands */
 222:Src/bldc.c    ****     RIGHT_TIM->RIGHT_TIM_U  = (uint16_t)CLAMP(ur + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 581              		.loc 1 222 0 discriminator 8
 582 03b8 01F57A70 		add	r0, r1, #1000
 583 03bc 40F26274 		movw	r4, #1890
 584 03c0 A042     		cmp	r0, r4
 585 03c2 05DC     		bgt	.L29
 586              		.loc 1 222 0 is_stmt 0 discriminator 2
 587 03c4 6D28     		cmp	r0, #109
 588 03c6 11DD     		ble	.L30
 589              		.loc 1 222 0 discriminator 4
 590 03c8 81B2     		uxth	r1, r0
 591              	.LVL40:
 592 03ca 03E0     		b	.L17
 593              	.LVL41:
 594              	.L28:
 187:Src/bldc.c    ****   // =================================================================
 595              		.loc 1 187 0 is_stmt 1
 596 03cc 6E23     		movs	r3, #110
 597              	.LVL42:
 598 03ce BDE7     		b	.L16
 599              	.LVL43:
 600              	.L29:
 601              		.loc 1 222 0
 602 03d0 40F26271 		movw	r1, #1890
 603              	.LVL44:
 604              	.L17:
 605              		.loc 1 222 0 is_stmt 0 discriminator 8
 606 03d4 1E48     		ldr	r0, .L42+44
 607              	.LVL45:
 608 03d6 4163     		str	r1, [r0, #52]
 609              	.LVL46:
 223:Src/bldc.c    ****     RIGHT_TIM->RIGHT_TIM_V  = (uint16_t)CLAMP(vr + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 610              		.loc 1 223 0 is_stmt 1 discriminator 8
 611 03d8 02F57A71 		add	r1, r2, #1000
 612 03dc 40F26270 		movw	r0, #1890
 613 03e0 8142     		cmp	r1, r0
 614 03e2 05DC     		bgt	.L31
 615              		.loc 1 223 0 is_stmt 0 discriminator 2
 616 03e4 6D29     		cmp	r1, #109
ARM GAS  /tmp/ccXT4x7r.s 			page 16


 617 03e6 11DD     		ble	.L32
 618              		.loc 1 223 0 discriminator 4
 619 03e8 8AB2     		uxth	r2, r1
 620              	.LVL47:
 621 03ea 03E0     		b	.L18
 622              	.LVL48:
 623              	.L30:
 222:Src/bldc.c    ****     RIGHT_TIM->RIGHT_TIM_V  = (uint16_t)CLAMP(vr + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 624              		.loc 1 222 0 is_stmt 1
 625 03ec 6E21     		movs	r1, #110
 626              	.LVL49:
 627 03ee F1E7     		b	.L17
 628              	.LVL50:
 629              	.L31:
 630              		.loc 1 223 0
 631 03f0 40F26272 		movw	r2, #1890
 632              	.LVL51:
 633              	.L18:
 634              		.loc 1 223 0 is_stmt 0 discriminator 8
 635 03f4 1649     		ldr	r1, .L42+44
 636              	.LVL52:
 637 03f6 8A63     		str	r2, [r1, #56]
 224:Src/bldc.c    ****     RIGHT_TIM->RIGHT_TIM_W  = (uint16_t)CLAMP(wr + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 638              		.loc 1 224 0 is_stmt 1 discriminator 8
 639 03f8 03F57A72 		add	r2, r3, #1000
 640 03fc 40F26271 		movw	r1, #1890
 641 0400 8A42     		cmp	r2, r1
 642 0402 05DC     		bgt	.L33
 643              		.loc 1 224 0 is_stmt 0 discriminator 2
 644 0404 6D2A     		cmp	r2, #109
 645 0406 0BDD     		ble	.L34
 646              		.loc 1 224 0 discriminator 4
 647 0408 93B2     		uxth	r3, r2
 648              	.LVL53:
 649 040a 03E0     		b	.L19
 650              	.LVL54:
 651              	.L32:
 223:Src/bldc.c    ****     RIGHT_TIM->RIGHT_TIM_V  = (uint16_t)CLAMP(vr + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 652              		.loc 1 223 0 is_stmt 1
 653 040c 6E22     		movs	r2, #110
 654              	.LVL55:
 655 040e F1E7     		b	.L18
 656              	.LVL56:
 657              	.L33:
 658              		.loc 1 224 0
 659 0410 40F26273 		movw	r3, #1890
 660              	.LVL57:
 661              	.L19:
 662              		.loc 1 224 0 is_stmt 0 discriminator 8
 663 0414 0E4A     		ldr	r2, .L42+44
 664              	.LVL58:
 665 0416 D363     		str	r3, [r2, #60]
 225:Src/bldc.c    ****   // =================================================================
 226:Src/bldc.c    **** 
 227:Src/bldc.c    ****   /* Indicate task complete */
 228:Src/bldc.c    ****   OverrunFlag = false;
 666              		.loc 1 228 0 is_stmt 1 discriminator 8
ARM GAS  /tmp/ccXT4x7r.s 			page 17


 667 0418 0022     		movs	r2, #0
 668 041a 0E4B     		ldr	r3, .L42+48
 669 041c 1A70     		strb	r2, [r3]
 670              	.LVL59:
 671              	.L1:
 672 041e 10BD     		pop	{r4, pc}
 673              	.LVL60:
 674              	.L34:
 224:Src/bldc.c    ****     RIGHT_TIM->RIGHT_TIM_W  = (uint16_t)CLAMP(wr + pwm_res / 2, pwm_margin, pwm_res-pwm_margin);
 675              		.loc 1 224 0
 676 0420 6E23     		movs	r3, #110
 677              	.LVL61:
 678 0422 F7E7     		b	.L19
 679              	.L43:
 680              		.align	2
 681              	.L42:
 682 0424 00340140 		.word	1073820672
 683 0428 00100140 		.word	1073811456
 684 042c 00000000 		.word	rtU_Right
 685 0430 00000000 		.word	.LANCHOR20
 686 0434 00000000 		.word	ctrlModReq
 687 0438 00000000 		.word	.LANCHOR22
 688 043c 00000000 		.word	.LANCHOR13
 689 0440 00000000 		.word	.LANCHOR14
 690 0444 00000000 		.word	.LANCHOR15
 691 0448 00000000 		.word	rtM_Right
 692 044c 00000000 		.word	rtY_Right
 693 0450 002C0140 		.word	1073818624
 694 0454 00000000 		.word	.LANCHOR19
 695              		.cfi_endproc
 696              	.LFE64:
 698              		.global	batVoltage
 699              		.global	enable
 700              		.global	buzzerPattern
 701              		.global	buzzerFreq
 702              		.global	pwmr
 703              		.global	pwml
 704              		.global	curR_DC
 705              		.global	curR_phaC
 706              		.global	curR_phaB
 707              		.global	curL_DC
 708              		.global	curL_phaB
 709              		.global	curL_phaA
 710              		.section	.bss.OverrunFlag.7706,"aw",%nobits
 711              		.set	.LANCHOR19,. + 0
 714              	OverrunFlag.7706:
 715 0000 00       		.space	1
 716              		.section	.bss.buzzerFreq,"aw",%nobits
 717              		.set	.LANCHOR17,. + 0
 720              	buzzerFreq:
 721 0000 00       		.space	1
 722              		.section	.bss.buzzerPattern,"aw",%nobits
 723              		.set	.LANCHOR18,. + 0
 726              	buzzerPattern:
 727 0000 00       		.space	1
 728              		.section	.bss.buzzerTimer,"aw",%nobits
 729              		.align	2
ARM GAS  /tmp/ccXT4x7r.s 			page 18


 730              		.set	.LANCHOR7,. + 0
 733              	buzzerTimer:
 734 0000 00000000 		.space	4
 735              		.section	.bss.curL_DC,"aw",%nobits
 736              		.align	1
 737              		.set	.LANCHOR12,. + 0
 740              	curL_DC:
 741 0000 0000     		.space	2
 742              		.section	.bss.curL_phaA,"aw",%nobits
 743              		.align	1
 744              		.set	.LANCHOR10,. + 0
 747              	curL_phaA:
 748 0000 0000     		.space	2
 749              		.section	.bss.curL_phaB,"aw",%nobits
 750              		.align	1
 751              		.set	.LANCHOR11,. + 0
 754              	curL_phaB:
 755 0000 0000     		.space	2
 756              		.section	.bss.curR_DC,"aw",%nobits
 757              		.align	1
 758              		.set	.LANCHOR15,. + 0
 761              	curR_DC:
 762 0000 0000     		.space	2
 763              		.section	.bss.curR_phaB,"aw",%nobits
 764              		.align	1
 765              		.set	.LANCHOR13,. + 0
 768              	curR_phaB:
 769 0000 0000     		.space	2
 770              		.section	.bss.curR_phaC,"aw",%nobits
 771              		.align	1
 772              		.set	.LANCHOR14,. + 0
 775              	curR_phaC:
 776 0000 0000     		.space	2
 777              		.section	.bss.enable,"aw",%nobits
 778              		.set	.LANCHOR16,. + 0
 781              	enable:
 782 0000 00       		.space	1
 783              		.section	.bss.enableFin,"aw",%nobits
 784              		.set	.LANCHOR20,. + 0
 787              	enableFin:
 788 0000 00       		.space	1
 789              		.section	.bss.offsetcount,"aw",%nobits
 790              		.align	1
 791              		.set	.LANCHOR0,. + 0
 794              	offsetcount:
 795 0000 0000     		.space	2
 796              		.section	.bss.pwml,"aw",%nobits
 797              		.align	2
 798              		.set	.LANCHOR21,. + 0
 801              	pwml:
 802 0000 00000000 		.space	4
 803              		.section	.bss.pwmr,"aw",%nobits
 804              		.align	2
 805              		.set	.LANCHOR22,. + 0
 808              	pwmr:
 809 0000 00000000 		.space	4
 810              		.section	.data.batVoltage,"aw",%progbits
ARM GAS  /tmp/ccXT4x7r.s 			page 19


 811              		.align	1
 812              		.set	.LANCHOR9,. + 0
 815              	batVoltage:
 816 0000 DF05     		.short	1503
 817              		.section	.data.batVoltageFixdt,"aw",%progbits
 818              		.align	2
 819              		.set	.LANCHOR8,. + 0
 822              	batVoltageFixdt:
 823 0000 0000DF05 		.word	98500608
 824              		.section	.data.offsetdcl,"aw",%progbits
 825              		.align	1
 826              		.set	.LANCHOR5,. + 0
 829              	offsetdcl:
 830 0000 D007     		.short	2000
 831              		.section	.data.offsetdcr,"aw",%progbits
 832              		.align	1
 833              		.set	.LANCHOR6,. + 0
 836              	offsetdcr:
 837 0000 D007     		.short	2000
 838              		.section	.data.offsetrlA,"aw",%progbits
 839              		.align	1
 840              		.set	.LANCHOR1,. + 0
 843              	offsetrlA:
 844 0000 D007     		.short	2000
 845              		.section	.data.offsetrlB,"aw",%progbits
 846              		.align	1
 847              		.set	.LANCHOR2,. + 0
 850              	offsetrlB:
 851 0000 D007     		.short	2000
 852              		.section	.data.offsetrrB,"aw",%progbits
 853              		.align	1
 854              		.set	.LANCHOR3,. + 0
 857              	offsetrrB:
 858 0000 D007     		.short	2000
 859              		.section	.data.offsetrrC,"aw",%progbits
 860              		.align	1
 861              		.set	.LANCHOR4,. + 0
 864              	offsetrrC:
 865 0000 D007     		.short	2000
 866              		.text
 867              	.Letext0:
 868              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 869              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 870              		.file 4 "Drivers/CMSIS/Include/core_cm3.h"
 871              		.file 5 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 872              		.file 6 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 873              		.file 7 "/usr/include/newlib/sys/lock.h"
 874              		.file 8 "/usr/include/newlib/sys/_types.h"
 875              		.file 9 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 876              		.file 10 "/usr/include/newlib/sys/reent.h"
 877              		.file 11 "Inc/defines.h"
 878              		.file 12 "Inc/rtwtypes.h"
 879              		.file 13 "Inc/BLDC_controller.h"
 880              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 881              		.file 15 "Inc/util.h"
ARM GAS  /tmp/ccXT4x7r.s 			page 20


DEFINED SYMBOLS
                            *ABS*:0000000000000000 bldc.c
     /tmp/ccXT4x7r.s:16     .text.DMA1_Channel1_IRQHandler:0000000000000000 $t
     /tmp/ccXT4x7r.s:23     .text.DMA1_Channel1_IRQHandler:0000000000000000 DMA1_Channel1_IRQHandler
     /tmp/ccXT4x7r.s:408    .text.DMA1_Channel1_IRQHandler:000000000000027c $d
     /tmp/ccXT4x7r.s:446    .text.DMA1_Channel1_IRQHandler:0000000000000308 $t
     /tmp/ccXT4x7r.s:682    .text.DMA1_Channel1_IRQHandler:0000000000000424 $d
     /tmp/ccXT4x7r.s:815    .data.batVoltage:0000000000000000 batVoltage
     /tmp/ccXT4x7r.s:781    .bss.enable:0000000000000000 enable
     /tmp/ccXT4x7r.s:726    .bss.buzzerPattern:0000000000000000 buzzerPattern
     /tmp/ccXT4x7r.s:720    .bss.buzzerFreq:0000000000000000 buzzerFreq
     /tmp/ccXT4x7r.s:808    .bss.pwmr:0000000000000000 pwmr
     /tmp/ccXT4x7r.s:801    .bss.pwml:0000000000000000 pwml
     /tmp/ccXT4x7r.s:761    .bss.curR_DC:0000000000000000 curR_DC
     /tmp/ccXT4x7r.s:775    .bss.curR_phaC:0000000000000000 curR_phaC
     /tmp/ccXT4x7r.s:768    .bss.curR_phaB:0000000000000000 curR_phaB
     /tmp/ccXT4x7r.s:740    .bss.curL_DC:0000000000000000 curL_DC
     /tmp/ccXT4x7r.s:754    .bss.curL_phaB:0000000000000000 curL_phaB
     /tmp/ccXT4x7r.s:747    .bss.curL_phaA:0000000000000000 curL_phaA
     /tmp/ccXT4x7r.s:714    .bss.OverrunFlag.7706:0000000000000000 OverrunFlag.7706
     /tmp/ccXT4x7r.s:715    .bss.OverrunFlag.7706:0000000000000000 $d
     /tmp/ccXT4x7r.s:721    .bss.buzzerFreq:0000000000000000 $d
     /tmp/ccXT4x7r.s:727    .bss.buzzerPattern:0000000000000000 $d
     /tmp/ccXT4x7r.s:729    .bss.buzzerTimer:0000000000000000 $d
     /tmp/ccXT4x7r.s:733    .bss.buzzerTimer:0000000000000000 buzzerTimer
     /tmp/ccXT4x7r.s:736    .bss.curL_DC:0000000000000000 $d
     /tmp/ccXT4x7r.s:743    .bss.curL_phaA:0000000000000000 $d
     /tmp/ccXT4x7r.s:750    .bss.curL_phaB:0000000000000000 $d
     /tmp/ccXT4x7r.s:757    .bss.curR_DC:0000000000000000 $d
     /tmp/ccXT4x7r.s:764    .bss.curR_phaB:0000000000000000 $d
     /tmp/ccXT4x7r.s:771    .bss.curR_phaC:0000000000000000 $d
     /tmp/ccXT4x7r.s:782    .bss.enable:0000000000000000 $d
     /tmp/ccXT4x7r.s:787    .bss.enableFin:0000000000000000 enableFin
     /tmp/ccXT4x7r.s:788    .bss.enableFin:0000000000000000 $d
     /tmp/ccXT4x7r.s:790    .bss.offsetcount:0000000000000000 $d
     /tmp/ccXT4x7r.s:794    .bss.offsetcount:0000000000000000 offsetcount
     /tmp/ccXT4x7r.s:797    .bss.pwml:0000000000000000 $d
     /tmp/ccXT4x7r.s:804    .bss.pwmr:0000000000000000 $d
     /tmp/ccXT4x7r.s:811    .data.batVoltage:0000000000000000 $d
     /tmp/ccXT4x7r.s:818    .data.batVoltageFixdt:0000000000000000 $d
     /tmp/ccXT4x7r.s:822    .data.batVoltageFixdt:0000000000000000 batVoltageFixdt
     /tmp/ccXT4x7r.s:825    .data.offsetdcl:0000000000000000 $d
     /tmp/ccXT4x7r.s:829    .data.offsetdcl:0000000000000000 offsetdcl
     /tmp/ccXT4x7r.s:832    .data.offsetdcr:0000000000000000 $d
     /tmp/ccXT4x7r.s:836    .data.offsetdcr:0000000000000000 offsetdcr
     /tmp/ccXT4x7r.s:839    .data.offsetrlA:0000000000000000 $d
     /tmp/ccXT4x7r.s:843    .data.offsetrlA:0000000000000000 offsetrlA
     /tmp/ccXT4x7r.s:846    .data.offsetrlB:0000000000000000 $d
     /tmp/ccXT4x7r.s:850    .data.offsetrlB:0000000000000000 offsetrlB
     /tmp/ccXT4x7r.s:853    .data.offsetrrB:0000000000000000 $d
     /tmp/ccXT4x7r.s:857    .data.offsetrrB:0000000000000000 offsetrrB
     /tmp/ccXT4x7r.s:860    .data.offsetrrC:0000000000000000 $d
     /tmp/ccXT4x7r.s:864    .data.offsetrrC:0000000000000000 offsetrrC
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_GPIO_TogglePin
ARM GAS  /tmp/ccXT4x7r.s 			page 21


filtLowPass32
HAL_GPIO_WritePin
BLDC_controller_step
adc_buffer
rtY_Left
rtY_Right
rtU_Left
ctrlModReq
rtM_Left
rtU_Right
rtM_Right
