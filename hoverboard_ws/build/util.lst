ARM GAS  /tmp/ccCqBQUf.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.BLDC_Init,"ax",%progbits
  16              		.align	1
  17              		.global	BLDC_Init
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	BLDC_Init:
  24              	.LFB64:
  25              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdlib.h> // for abs()
  22:Src/util.c    **** #include <string.h>
  23:Src/util.c    **** #include "stm32f1xx_hal.h"
  24:Src/util.c    **** #include "defines.h"
  25:Src/util.c    **** #include "setup.h"
  26:Src/util.c    **** #include "config.h"
  27:Src/util.c    **** #include "comms.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
  32:Src/util.c    **** 
  33:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
ARM GAS  /tmp/ccCqBQUf.s 			page 2


  34:Src/util.c    **** #include "hd44780.h"
  35:Src/util.c    **** #endif
  36:Src/util.c    **** 
  37:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  38:Src/util.c    **** 
  39:Src/util.c    **** //------------------------------------------------------------------------
  40:Src/util.c    **** // Global variables set externally
  41:Src/util.c    **** //------------------------------------------------------------------------
  42:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  43:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  44:Src/util.c    **** extern UART_HandleTypeDef huart2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart3;
  46:Src/util.c    **** 
  47:Src/util.c    **** extern int16_t batVoltage;
  48:Src/util.c    **** extern uint8_t backwardDrive;
  49:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  50:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  51:Src/util.c    **** 
  52:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  53:Src/util.c    **** 
  54:Src/util.c    **** extern uint8_t nunchuk_data[6];
  55:Src/util.c    **** extern volatile uint32_t timeoutCnt;    // global variable for general timeout counter
  56:Src/util.c    **** extern volatile uint32_t main_loop_counter;
  57:Src/util.c    **** 
  58:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  59:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  60:Src/util.c    **** #endif
  61:Src/util.c    **** 
  62:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  63:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  64:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  65:Src/util.c    **** #endif
  66:Src/util.c    **** 
  67:Src/util.c    **** #ifdef BUTTONS_RIGHT
  68:Src/util.c    **** extern volatile uint8_t btn1;  // Blue
  69:Src/util.c    **** extern volatile uint8_t btn2;  // Green
  70:Src/util.c    **** #endif
  71:Src/util.c    **** 
  72:Src/util.c    **** 
  73:Src/util.c    **** //------------------------------------------------------------------------
  74:Src/util.c    **** // Global variables set here in util.c
  75:Src/util.c    **** //------------------------------------------------------------------------
  76:Src/util.c    **** // Matlab defines - from auto-code generation
  77:Src/util.c    **** //---------------
  78:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  79:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  80:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  81:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  82:Src/util.c    **** 
  83:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  84:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  85:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  86:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  87:Src/util.c    **** 
  88:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  89:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  90:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
ARM GAS  /tmp/ccCqBQUf.s 			page 3


  91:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
  92:Src/util.c    **** //---------------
  93:Src/util.c    **** 
  94:Src/util.c    **** int16_t  cmd1;                          // normalized input value. -1000 to 1000
  95:Src/util.c    **** int16_t  cmd2;                          // normalized input value. -1000 to 1000
  96:Src/util.c    **** 
  97:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
  98:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
  99:Src/util.c    **** uint8_t  timeoutFlagADC    = 0;         // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 100:Src/util.c    **** uint8_t  timeoutFlagSerial = 0;         // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 101:Src/util.c    **** 
 102:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 103:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 104:Src/util.c    **** 
 105:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 106:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 107:Src/util.c    **** #endif
 108:Src/util.c    **** 
 109:Src/util.c    **** #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 110:Src/util.c    **** uint8_t nunchuk_connected = 1;
 111:Src/util.c    **** #else
 112:Src/util.c    **** uint8_t nunchuk_connected = 0;
 113:Src/util.c    **** #endif
 114:Src/util.c    **** 
 115:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 116:Src/util.c    **** float    setDistance;
 117:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {0x1337};     // Virtual address defined by the user: 0xFFFF va
 118:Src/util.c    **** static   uint16_t saveValue       = 0;
 119:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 120:Src/util.c    **** #elif defined(CONTROL_ADC)
 121:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {0x1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308};
 122:Src/util.c    **** #else
 123:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {0x1300};     // Dummy virtual address to avoid warnings
 124:Src/util.c    **** #endif
 125:Src/util.c    **** 
 126:Src/util.c    **** 
 127:Src/util.c    **** //------------------------------------------------------------------------
 128:Src/util.c    **** // Local variables
 129:Src/util.c    **** //------------------------------------------------------------------------
 130:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 131:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 132:Src/util.c    **** 
 133:Src/util.c    **** #ifdef CONTROL_ADC
 134:Src/util.c    ****   static uint8_t  cur_spd_valid = 0;
 135:Src/util.c    ****   static uint8_t  adc_cal_valid = 0;
 136:Src/util.c    ****   static uint16_t ADC1_MIN_CAL = ADC1_MIN;
 137:Src/util.c    ****   static uint16_t ADC1_MAX_CAL = ADC1_MAX;
 138:Src/util.c    ****   static uint16_t ADC2_MIN_CAL = ADC2_MIN;
 139:Src/util.c    ****   static uint16_t ADC2_MAX_CAL = ADC2_MAX;
 140:Src/util.c    ****   #ifdef ADC1_MID_POT
 141:Src/util.c    ****   static uint16_t ADC1_MID_CAL = ADC1_MID;
 142:Src/util.c    ****   #else
 143:Src/util.c    ****   static uint16_t ADC1_MID_CAL = 0;
 144:Src/util.c    ****   #endif
 145:Src/util.c    ****   #ifdef ADC1_MID_POT
 146:Src/util.c    ****   static uint16_t ADC2_MID_CAL = ADC2_MID;
 147:Src/util.c    ****   #else
ARM GAS  /tmp/ccCqBQUf.s 			page 4


 148:Src/util.c    ****   static uint16_t ADC2_MID_CAL = 0;
 149:Src/util.c    ****   #endif
 150:Src/util.c    **** #endif
 151:Src/util.c    **** 
 152:Src/util.c    **** #if defined(CONTROL_ADC) && defined(ADC_PROTECT_ENA)
 153:Src/util.c    **** static int16_t timeoutCntADC   = 0;  // Timeout counter for ADC Protection
 154:Src/util.c    **** #endif
 155:Src/util.c    **** 
 156:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 157:Src/util.c    **** static uint8_t rx_buffer_L[SERIAL_BUFFER_SIZE];	// USART Rx DMA circular buffer
 158:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
 159:Src/util.c    **** #endif
 160:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 161:Src/util.c    **** static uint16_t timeoutCntSerial_L  = 0;  		// Timeout counter for Rx Serial command
 162:Src/util.c    **** static uint8_t  timeoutFlagSerial_L = 0;  		// Timeout Flag for Rx Serial command: 0 = OK, 1 = Prob
 163:Src/util.c    **** #endif
 164:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 165:Src/util.c    **** SerialSideboard Sideboard_L;
 166:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 167:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 168:Src/util.c    **** #endif
 169:Src/util.c    **** 
 170:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 171:Src/util.c    **** static uint8_t rx_buffer_R[SERIAL_BUFFER_SIZE]; // USART Rx DMA circular buffer
 172:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 173:Src/util.c    **** #endif
 174:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 175:Src/util.c    **** static uint16_t timeoutCntSerial_R  = 0;  		// Timeout counter for Rx Serial command
 176:Src/util.c    **** static uint8_t  timeoutFlagSerial_R = 0;  		// Timeout Flag for Rx Serial command: 0 = OK, 1 = Prob
 177:Src/util.c    **** #endif
 178:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 179:Src/util.c    **** SerialSideboard Sideboard_R;
 180:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 181:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 182:Src/util.c    **** #endif
 183:Src/util.c    **** 
 184:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
 185:Src/util.c    **** static SerialCommand command;
 186:Src/util.c    **** static SerialCommand command_raw;
 187:Src/util.c    **** static uint32_t command_len = sizeof(command);
 188:Src/util.c    ****   #ifdef CONTROL_IBUS
 189:Src/util.c    ****   static uint16_t ibus_chksum;
 190:Src/util.c    ****   static uint16_t ibus_captured_value[IBUS_NUM_CHANNELS];
 191:Src/util.c    ****   #endif
 192:Src/util.c    **** #endif
 193:Src/util.c    **** 
 194:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_U
 195:Src/util.c    **** static uint8_t  sensor1_prev;           // holds the previous sensor1 state
 196:Src/util.c    **** static uint8_t  sensor2_prev;           // holds the previous sensor2 state
 197:Src/util.c    **** static uint8_t  sensor1_index;          // holds the press index number for sensor1, when used as a
 198:Src/util.c    **** static uint8_t  sensor2_index;          // holds the press index number for sensor2, when used as a
 199:Src/util.c    **** #endif
 200:Src/util.c    **** 
 201:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 202:Src/util.c    **** static uint8_t button1, button2;
 203:Src/util.c    **** #endif
 204:Src/util.c    **** 
ARM GAS  /tmp/ccCqBQUf.s 			page 5


 205:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 206:Src/util.c    **** static uint8_t brakePressed;
 207:Src/util.c    **** #endif
 208:Src/util.c    **** 
 209:Src/util.c    **** 
 210:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 211:Src/util.c    **** 
 212:Src/util.c    **** void BLDC_Init(void) {
  26              		.loc 1 212 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 70B5     		push	{r4, r5, r6, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 16
  33              		.cfi_offset 4, -16
  34              		.cfi_offset 5, -12
  35              		.cfi_offset 6, -8
  36              		.cfi_offset 14, -4
 213:Src/util.c    ****   /* Set BLDC controller parameters */ 
 214:Src/util.c    ****   rtP_Left.b_selPhaABCurrMeas   = 1;            // Left motor measured current phases {Green, Blue}
  37              		.loc 1 214 0
  38 0002 204C     		ldr	r4, .L3
  39 0004 0123     		movs	r3, #1
  40 0006 84F8F930 		strb	r3, [r4, #249]
 215:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
  41              		.loc 1 215 0
  42 000a 0222     		movs	r2, #2
  43 000c 84F8F620 		strb	r2, [r4, #246]
 216:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA; 
  44              		.loc 1 216 0
  45 0010 84F8F730 		strb	r3, [r4, #247]
 217:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
  46              		.loc 1 217 0
  47 0014 42F6E063 		movw	r3, #12000
  48 0018 A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 218:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
  49              		.loc 1 218 0
  50 001c 4FF47A53 		mov	r3, #16000
  51 0020 A4F8D830 		strh	r3, [r4, #216]	@ movhi
 219:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
  52              		.loc 1 219 0
  53 0024 0026     		movs	r6, #0
  54 0026 84F8F860 		strb	r6, [r4, #248]
 220:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
  55              		.loc 1 220 0
  56 002a 4FF47A62 		mov	r2, #4000
  57 002e A4F8CE20 		strh	r2, [r4, #206]	@ movhi
 221:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
  58              		.loc 1 221 0
  59 0032 4FF4C872 		mov	r2, #400
  60 0036 A4F8CA20 		strh	r2, [r4, #202]	@ movhi
 222:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
  61              		.loc 1 222 0
  62 003a 45F6C052 		movw	r2, #24000
  63 003e A4F8DE20 		strh	r2, [r4, #222]	@ movhi
 223:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
ARM GAS  /tmp/ccCqBQUf.s 			page 6


  64              		.loc 1 223 0
  65 0042 A4F8E030 		strh	r3, [r4, #224]	@ movhi
 224:Src/util.c    **** 
 225:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
  66              		.loc 1 225 0
  67 0046 104D     		ldr	r5, .L3+4
  68 0048 FC22     		movs	r2, #252
  69 004a 2146     		mov	r1, r4
  70 004c 2846     		mov	r0, r5
  71 004e FFF7FEFF 		bl	memcpy
  72              	.LVL0:
 226:Src/util.c    ****   rtP_Right.b_selPhaABCurrMeas  = 0;            // Right motor measured current phases {Blue, Yello
  73              		.loc 1 226 0
  74 0052 85F8F960 		strb	r6, [r5, #249]
 227:Src/util.c    **** 
 228:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 229:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
  75              		.loc 1 229 0
  76 0056 0D48     		ldr	r0, .L3+8
  77 0058 0460     		str	r4, [r0]
 230:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
  78              		.loc 1 230 0
  79 005a 0D4B     		ldr	r3, .L3+12
  80 005c C360     		str	r3, [r0, #12]
 231:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
  81              		.loc 1 231 0
  82 005e 0D4B     		ldr	r3, .L3+16
  83 0060 4360     		str	r3, [r0, #4]
 232:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
  84              		.loc 1 232 0
  85 0062 0D4B     		ldr	r3, .L3+20
  86 0064 8360     		str	r3, [r0, #8]
 233:Src/util.c    **** 
 234:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 235:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
  87              		.loc 1 235 0
  88 0066 0D4C     		ldr	r4, .L3+24
  89 0068 2560     		str	r5, [r4]
 236:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
  90              		.loc 1 236 0
  91 006a 0D4B     		ldr	r3, .L3+28
  92 006c E360     		str	r3, [r4, #12]
 237:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
  93              		.loc 1 237 0
  94 006e 0D4B     		ldr	r3, .L3+32
  95 0070 6360     		str	r3, [r4, #4]
 238:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
  96              		.loc 1 238 0
  97 0072 0D4B     		ldr	r3, .L3+36
  98 0074 A360     		str	r3, [r4, #8]
 239:Src/util.c    **** 
 240:Src/util.c    ****   /* Initialize BLDC controllers */
 241:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
  99              		.loc 1 241 0
 100 0076 FFF7FEFF 		bl	BLDC_controller_initialize
 101              	.LVL1:
 242:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
ARM GAS  /tmp/ccCqBQUf.s 			page 7


 102              		.loc 1 242 0
 103 007a 2046     		mov	r0, r4
 104 007c FFF7FEFF 		bl	BLDC_controller_initialize
 105              	.LVL2:
 106 0080 70BD     		pop	{r4, r5, r6, pc}
 107              	.L4:
 108 0082 00BF     		.align	2
 109              	.L3:
 110 0084 00000000 		.word	rtP_Left
 111 0088 00000000 		.word	rtP_Right
 112 008c 00000000 		.word	rtM_Left_
 113 0090 00000000 		.word	rtDW_Left
 114 0094 00000000 		.word	rtU_Left
 115 0098 00000000 		.word	rtY_Left
 116 009c 00000000 		.word	rtM_Right_
 117 00a0 00000000 		.word	rtDW_Right
 118 00a4 00000000 		.word	rtU_Right
 119 00a8 00000000 		.word	rtY_Right
 120              		.cfi_endproc
 121              	.LFE64:
 123              		.section	.text.Input_Lim_Init,"ax",%progbits
 124              		.align	1
 125              		.global	Input_Lim_Init
 126              		.syntax unified
 127              		.thumb
 128              		.thumb_func
 129              		.fpu softvfp
 131              	Input_Lim_Init:
 132              	.LFB65:
 243:Src/util.c    **** }
 244:Src/util.c    **** 
 245:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !    
 133              		.loc 1 245 0
 134              		.cfi_startproc
 135              		@ args = 0, pretend = 0, frame = 0
 136              		@ frame_needed = 0, uses_anonymous_args = 0
 137              		@ link register save eliminated.
 246:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 138              		.loc 1 246 0
 139 0000 0C4B     		ldr	r3, .L9
 140 0002 93F8F830 		ldrb	r3, [r3, #248]	@ zero_extendqisi2
 141 0006 63B9     		cbnz	r3, .L6
 142              		.loc 1 246 0 is_stmt 0 discriminator 1
 143 0008 0B4B     		ldr	r3, .L9+4
 144 000a 93F8F830 		ldrb	r3, [r3, #248]	@ zero_extendqisi2
 145 000e 43B9     		cbnz	r3, .L6
 247:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 248:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 249:Src/util.c    ****   } else {
 250:Src/util.c    ****     INPUT_MAX =  1000;
 146              		.loc 1 250 0 is_stmt 1
 147 0010 4FF47A72 		mov	r2, #1000
 148 0014 094B     		ldr	r3, .L9+8
 149 0016 1A80     		strh	r2, [r3]	@ movhi
 251:Src/util.c    ****     INPUT_MIN = -1000;
 150              		.loc 1 251 0
 151 0018 4FF61842 		movw	r2, #64536
ARM GAS  /tmp/ccCqBQUf.s 			page 8


 152 001c 084B     		ldr	r3, .L9+12
 153 001e 1A80     		strh	r2, [r3]	@ movhi
 154 0020 7047     		bx	lr
 155              	.L6:
 247:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 156              		.loc 1 247 0
 157 0022 40F2DC52 		movw	r2, #1500
 158 0026 054B     		ldr	r3, .L9+8
 159 0028 1A80     		strh	r2, [r3]	@ movhi
 248:Src/util.c    ****   } else {
 160              		.loc 1 248 0
 161 002a 4FF62422 		movw	r2, #64036
 162 002e 044B     		ldr	r3, .L9+12
 163 0030 1A80     		strh	r2, [r3]	@ movhi
 164 0032 7047     		bx	lr
 165              	.L10:
 166              		.align	2
 167              	.L9:
 168 0034 00000000 		.word	rtP_Left
 169 0038 00000000 		.word	rtP_Right
 170 003c 00000000 		.word	.LANCHOR0
 171 0040 00000000 		.word	.LANCHOR1
 172              		.cfi_endproc
 173              	.LFE65:
 175              		.section	.text.UART_DisableRxErrors,"ax",%progbits
 176              		.align	1
 177              		.global	UART_DisableRxErrors
 178              		.syntax unified
 179              		.thumb
 180              		.thumb_func
 181              		.fpu softvfp
 183              	UART_DisableRxErrors:
 184              	.LFB67:
 252:Src/util.c    ****   }
 253:Src/util.c    **** }
 254:Src/util.c    **** 
 255:Src/util.c    **** void Input_Init(void) {
 256:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 257:Src/util.c    ****     PPM_Init();
 258:Src/util.c    ****   #endif
 259:Src/util.c    **** 
 260:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 261:Src/util.c    ****     PWM_Init();
 262:Src/util.c    ****   #endif
 263:Src/util.c    **** 
 264:Src/util.c    ****   #ifdef CONTROL_NUNCHUK
 265:Src/util.c    ****     I2C_Init();
 266:Src/util.c    ****     Nunchuk_Init();
 267:Src/util.c    ****   #endif
 268:Src/util.c    **** 
 269:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
 270:Src/util.c    ****     UART2_Init();
 271:Src/util.c    ****   #endif
 272:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 273:Src/util.c    ****     UART3_Init();
 274:Src/util.c    ****   #endif
 275:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
ARM GAS  /tmp/ccCqBQUf.s 			page 9


 276:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 277:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 278:Src/util.c    ****   #endif
 279:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 280:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 281:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 282:Src/util.c    ****   #endif
 283:Src/util.c    **** 
 284:Src/util.c    ****   #ifdef CONTROL_ADC  
 285:Src/util.c    **** 
 286:Src/util.c    ****     uint16_t writeCheck, i_max, n_max;
 287:Src/util.c    ****     HAL_FLASH_Unlock();    
 288:Src/util.c    ****     EE_Init();            /* EEPROM Init */    
 289:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 290:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 291:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1], &ADC1_MIN_CAL);
 292:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2], &ADC1_MAX_CAL);
 293:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[3], &ADC1_MID_CAL);
 294:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[4], &ADC2_MIN_CAL);
 295:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[5], &ADC2_MAX_CAL);
 296:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[6], &ADC2_MID_CAL);
 297:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[7], &i_max);
 298:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[8], &n_max);
 299:Src/util.c    ****       rtP_Left.i_max  = i_max;
 300:Src/util.c    ****       rtP_Left.n_max  = n_max;
 301:Src/util.c    ****       rtP_Right.i_max = i_max;
 302:Src/util.c    ****       rtP_Right.n_max = n_max;
 303:Src/util.c    ****     }
 304:Src/util.c    ****     HAL_FLASH_Lock();
 305:Src/util.c    **** 
 306:Src/util.c    ****   #endif
 307:Src/util.c    **** 
 308:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER    
 309:Src/util.c    ****     enable = 1;
 310:Src/util.c    ****     
 311:Src/util.c    ****     HAL_FLASH_Unlock();    
 312:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 313:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 314:Src/util.c    ****     HAL_FLASH_Lock();
 315:Src/util.c    **** 
 316:Src/util.c    ****     setDistance = saveValue / 1000.0;
 317:Src/util.c    ****     if (setDistance < 0.2) {
 318:Src/util.c    ****       setDistance = 1.0;
 319:Src/util.c    ****     }
 320:Src/util.c    ****   #endif
 321:Src/util.c    **** 
 322:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 323:Src/util.c    ****     I2C_Init();
 324:Src/util.c    ****     HAL_Delay(50);
 325:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 326:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 327:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 328:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 329:Src/util.c    ****     lcd.type                    = TYPE0;
 330:Src/util.c    **** 
 331:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
 332:Src/util.c    ****         // error occured
ARM GAS  /tmp/ccCqBQUf.s 			page 10


 333:Src/util.c    ****         //TODO while(1);
 334:Src/util.c    ****     }
 335:Src/util.c    **** 
 336:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 337:Src/util.c    ****     HAL_Delay(5);
 338:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 339:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 340:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 341:Src/util.c    ****     #else
 342:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 343:Src/util.c    ****     #endif
 344:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 345:Src/util.c    ****   #endif
 346:Src/util.c    **** 
 347:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 348:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 349:Src/util.c    ****     HAL_Delay(5);
 350:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 351:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 352:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 353:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 354:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 355:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 356:Src/util.c    ****   #endif
 357:Src/util.c    **** }
 358:Src/util.c    **** 
 359:Src/util.c    **** /**
 360:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 361:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 362:Src/util.c    ****   * @param  huart: UART handle.
 363:Src/util.c    ****   * @retval None
 364:Src/util.c    ****   */
 365:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 366:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 367:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 368:Src/util.c    **** {
 185              		.loc 1 368 0
 186              		.cfi_startproc
 187              		@ args = 0, pretend = 0, frame = 0
 188              		@ frame_needed = 0, uses_anonymous_args = 0
 189              		@ link register save eliminated.
 190              	.LVL3:
 369:Src/util.c    ****   /* Disable PE (Parity Error) interrupts */
 370:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 191              		.loc 1 370 0
 192 0000 0268     		ldr	r2, [r0]
 193 0002 D368     		ldr	r3, [r2, #12]
 194 0004 23F48073 		bic	r3, r3, #256
 195 0008 D360     		str	r3, [r2, #12]
 371:Src/util.c    **** 
 372:Src/util.c    ****   /* Disable EIE (Frame error, noise error, overrun error) interrupts */
 373:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 196              		.loc 1 373 0
 197 000a 0268     		ldr	r2, [r0]
 198 000c 5369     		ldr	r3, [r2, #20]
 199 000e 23F00103 		bic	r3, r3, #1
 200 0012 5361     		str	r3, [r2, #20]
ARM GAS  /tmp/ccCqBQUf.s 			page 11


 201 0014 7047     		bx	lr
 202              		.cfi_endproc
 203              	.LFE67:
 205              		.section	.text.Input_Init,"ax",%progbits
 206              		.align	1
 207              		.global	Input_Init
 208              		.syntax unified
 209              		.thumb
 210              		.thumb_func
 211              		.fpu softvfp
 213              	Input_Init:
 214              	.LFB66:
 255:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 215              		.loc 1 255 0
 216              		.cfi_startproc
 217              		@ args = 0, pretend = 0, frame = 0
 218              		@ frame_needed = 0, uses_anonymous_args = 0
 219 0000 10B5     		push	{r4, lr}
 220              	.LCFI1:
 221              		.cfi_def_cfa_offset 8
 222              		.cfi_offset 4, -8
 223              		.cfi_offset 14, -4
 273:Src/util.c    ****   #endif
 224              		.loc 1 273 0
 225 0002 FFF7FEFF 		bl	UART3_Init
 226              	.LVL4:
 280:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 227              		.loc 1 280 0
 228 0006 054C     		ldr	r4, .L14
 229 0008 4022     		movs	r2, #64
 230 000a 0549     		ldr	r1, .L14+4
 231 000c 2046     		mov	r0, r4
 232 000e FFF7FEFF 		bl	HAL_UART_Receive_DMA
 233              	.LVL5:
 281:Src/util.c    ****   #endif
 234              		.loc 1 281 0
 235 0012 2046     		mov	r0, r4
 236 0014 FFF7FEFF 		bl	UART_DisableRxErrors
 237              	.LVL6:
 238 0018 10BD     		pop	{r4, pc}
 239              	.L15:
 240 001a 00BF     		.align	2
 241              	.L14:
 242 001c 00000000 		.word	huart3
 243 0020 00000000 		.word	.LANCHOR2
 244              		.cfi_endproc
 245              	.LFE66:
 247              		.section	.text.poweronMelody,"ax",%progbits
 248              		.align	1
 249              		.global	poweronMelody
 250              		.syntax unified
 251              		.thumb
 252              		.thumb_func
 253              		.fpu softvfp
 255              	poweronMelody:
 256              	.LFB68:
 374:Src/util.c    **** }
ARM GAS  /tmp/ccCqBQUf.s 			page 12


 375:Src/util.c    **** #endif
 376:Src/util.c    **** 
 377:Src/util.c    **** 
 378:Src/util.c    **** /* =========================== General Functions =========================== */
 379:Src/util.c    **** 
 380:Src/util.c    **** void poweronMelody(void) {
 257              		.loc 1 380 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 0
 260              		@ frame_needed = 0, uses_anonymous_args = 0
 261 0000 10B5     		push	{r4, lr}
 262              	.LCFI2:
 263              		.cfi_def_cfa_offset 8
 264              		.cfi_offset 4, -8
 265              		.cfi_offset 14, -4
 266              	.LVL7:
 267              	.LBB2:
 381:Src/util.c    **** 	for (int i = 8; i >= 0; i--) {
 268              		.loc 1 381 0
 269 0002 0824     		movs	r4, #8
 270 0004 05E0     		b	.L17
 271              	.LVL8:
 272              	.L18:
 382:Src/util.c    **** 		buzzerFreq = (uint8_t)i;
 273              		.loc 1 382 0 discriminator 3
 274 0006 064B     		ldr	r3, .L20
 275 0008 1C70     		strb	r4, [r3]
 383:Src/util.c    **** 		HAL_Delay(100);
 276              		.loc 1 383 0 discriminator 3
 277 000a 6420     		movs	r0, #100
 278 000c FFF7FEFF 		bl	HAL_Delay
 279              	.LVL9:
 381:Src/util.c    **** 	for (int i = 8; i >= 0; i--) {
 280              		.loc 1 381 0 discriminator 3
 281 0010 013C     		subs	r4, r4, #1
 282              	.LVL10:
 283              	.L17:
 381:Src/util.c    **** 	for (int i = 8; i >= 0; i--) {
 284              		.loc 1 381 0 is_stmt 0 discriminator 1
 285 0012 002C     		cmp	r4, #0
 286 0014 F7DA     		bge	.L18
 287              	.LBE2:
 384:Src/util.c    **** 	}
 385:Src/util.c    **** 	buzzerFreq = 0;
 288              		.loc 1 385 0 is_stmt 1
 289 0016 0022     		movs	r2, #0
 290 0018 014B     		ldr	r3, .L20
 291 001a 1A70     		strb	r2, [r3]
 292 001c 10BD     		pop	{r4, pc}
 293              	.LVL11:
 294              	.L21:
 295 001e 00BF     		.align	2
 296              	.L20:
 297 0020 00000000 		.word	buzzerFreq
 298              		.cfi_endproc
 299              	.LFE68:
 301              		.section	.text.shortBeep,"ax",%progbits
ARM GAS  /tmp/ccCqBQUf.s 			page 13


 302              		.align	1
 303              		.global	shortBeep
 304              		.syntax unified
 305              		.thumb
 306              		.thumb_func
 307              		.fpu softvfp
 309              	shortBeep:
 310              	.LFB69:
 386:Src/util.c    **** }
 387:Src/util.c    **** 
 388:Src/util.c    **** void shortBeep(uint8_t freq) {
 311              		.loc 1 388 0
 312              		.cfi_startproc
 313              		@ args = 0, pretend = 0, frame = 0
 314              		@ frame_needed = 0, uses_anonymous_args = 0
 315              	.LVL12:
 316 0000 10B5     		push	{r4, lr}
 317              	.LCFI3:
 318              		.cfi_def_cfa_offset 8
 319              		.cfi_offset 4, -8
 320              		.cfi_offset 14, -4
 389:Src/util.c    ****     buzzerFreq = freq;
 321              		.loc 1 389 0
 322 0002 044C     		ldr	r4, .L24
 323 0004 2070     		strb	r0, [r4]
 390:Src/util.c    ****     HAL_Delay(100);
 324              		.loc 1 390 0
 325 0006 6420     		movs	r0, #100
 326              	.LVL13:
 327 0008 FFF7FEFF 		bl	HAL_Delay
 328              	.LVL14:
 391:Src/util.c    ****     buzzerFreq = 0;
 329              		.loc 1 391 0
 330 000c 0023     		movs	r3, #0
 331 000e 2370     		strb	r3, [r4]
 332 0010 10BD     		pop	{r4, pc}
 333              	.L25:
 334 0012 00BF     		.align	2
 335              	.L24:
 336 0014 00000000 		.word	buzzerFreq
 337              		.cfi_endproc
 338              	.LFE69:
 340              		.section	.text.shortBeepMany,"ax",%progbits
 341              		.align	1
 342              		.global	shortBeepMany
 343              		.syntax unified
 344              		.thumb
 345              		.thumb_func
 346              		.fpu softvfp
 348              	shortBeepMany:
 349              	.LFB70:
 392:Src/util.c    **** }
 393:Src/util.c    **** 
 394:Src/util.c    **** void shortBeepMany(uint8_t cnt) {
 350              		.loc 1 394 0
 351              		.cfi_startproc
 352              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccCqBQUf.s 			page 14


 353              		@ frame_needed = 0, uses_anonymous_args = 0
 354              	.LVL15:
 355 0000 38B5     		push	{r3, r4, r5, lr}
 356              	.LCFI4:
 357              		.cfi_def_cfa_offset 16
 358              		.cfi_offset 3, -16
 359              		.cfi_offset 4, -12
 360              		.cfi_offset 5, -8
 361              		.cfi_offset 14, -4
 362 0002 0546     		mov	r5, r0
 363              	.LVL16:
 364              	.LBB3:
 395:Src/util.c    ****     for(uint8_t i = 0; i < cnt; i++) {
 365              		.loc 1 395 0
 366 0004 0024     		movs	r4, #0
 367 0006 05E0     		b	.L27
 368              	.LVL17:
 369              	.L28:
 396:Src/util.c    ****       shortBeep(i + 5);
 370              		.loc 1 396 0 discriminator 3
 371 0008 601D     		adds	r0, r4, #5
 372 000a C0B2     		uxtb	r0, r0
 373 000c FFF7FEFF 		bl	shortBeep
 374              	.LVL18:
 395:Src/util.c    ****     for(uint8_t i = 0; i < cnt; i++) {
 375              		.loc 1 395 0 discriminator 3
 376 0010 0134     		adds	r4, r4, #1
 377              	.LVL19:
 378 0012 E4B2     		uxtb	r4, r4
 379              	.LVL20:
 380              	.L27:
 395:Src/util.c    ****     for(uint8_t i = 0; i < cnt; i++) {
 381              		.loc 1 395 0 is_stmt 0 discriminator 1
 382 0014 AC42     		cmp	r4, r5
 383 0016 F7D3     		bcc	.L28
 384              	.LBE3:
 397:Src/util.c    ****     }
 398:Src/util.c    **** }
 385              		.loc 1 398 0 is_stmt 1
 386 0018 38BD     		pop	{r3, r4, r5, pc}
 387              		.cfi_endproc
 388              	.LFE70:
 390              		.section	.text.longBeep,"ax",%progbits
 391              		.align	1
 392              		.global	longBeep
 393              		.syntax unified
 394              		.thumb
 395              		.thumb_func
 396              		.fpu softvfp
 398              	longBeep:
 399              	.LFB71:
 399:Src/util.c    **** 
 400:Src/util.c    **** void longBeep(uint8_t freq) {
 400              		.loc 1 400 0
 401              		.cfi_startproc
 402              		@ args = 0, pretend = 0, frame = 0
 403              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccCqBQUf.s 			page 15


 404              	.LVL21:
 405 0000 10B5     		push	{r4, lr}
 406              	.LCFI5:
 407              		.cfi_def_cfa_offset 8
 408              		.cfi_offset 4, -8
 409              		.cfi_offset 14, -4
 401:Src/util.c    ****     buzzerFreq = freq;
 410              		.loc 1 401 0
 411 0002 044C     		ldr	r4, .L32
 412 0004 2070     		strb	r0, [r4]
 402:Src/util.c    ****     HAL_Delay(500);
 413              		.loc 1 402 0
 414 0006 4FF4FA70 		mov	r0, #500
 415              	.LVL22:
 416 000a FFF7FEFF 		bl	HAL_Delay
 417              	.LVL23:
 403:Src/util.c    ****     buzzerFreq = 0;
 418              		.loc 1 403 0
 419 000e 0023     		movs	r3, #0
 420 0010 2370     		strb	r3, [r4]
 421 0012 10BD     		pop	{r4, pc}
 422              	.L33:
 423              		.align	2
 424              	.L32:
 425 0014 00000000 		.word	buzzerFreq
 426              		.cfi_endproc
 427              	.LFE71:
 429              		.section	.text.calcAvgSpeed,"ax",%progbits
 430              		.align	1
 431              		.global	calcAvgSpeed
 432              		.syntax unified
 433              		.thumb
 434              		.thumb_func
 435              		.fpu softvfp
 437              	calcAvgSpeed:
 438              	.LFB72:
 404:Src/util.c    **** }
 405:Src/util.c    **** 
 406:Src/util.c    **** void calcAvgSpeed(void) {
 439              		.loc 1 406 0
 440              		.cfi_startproc
 441              		@ args = 0, pretend = 0, frame = 0
 442              		@ frame_needed = 0, uses_anonymous_args = 0
 443              		@ link register save eliminated.
 407:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 408:Src/util.c    ****     #if   !defined(INVERT_L_DIRECTION) && !defined(INVERT_R_DIRECTION)
 409:Src/util.c    ****       speedAvg    = ( rtY_Left.n_mot - rtY_Right.n_mot) / 2;
 444              		.loc 1 409 0
 445 0000 094B     		ldr	r3, .L35
 446 0002 B3F90830 		ldrsh	r3, [r3, #8]
 447 0006 094A     		ldr	r2, .L35+4
 448 0008 B2F90820 		ldrsh	r2, [r2, #8]
 449 000c 9B1A     		subs	r3, r3, r2
 450 000e 03EBD373 		add	r3, r3, r3, lsr #31
 451 0012 43F34F03 		sbfx	r3, r3, #1, #16
 452 0016 064A     		ldr	r2, .L35+8
 453 0018 1380     		strh	r3, [r2]	@ movhi
ARM GAS  /tmp/ccCqBQUf.s 			page 16


 410:Src/util.c    ****     #elif !defined(INVERT_L_DIRECTION) &&  defined(INVERT_R_DIRECTION)
 411:Src/util.c    ****       speedAvg    = ( rtY_Left.n_mot + rtY_Right.n_mot) / 2;
 412:Src/util.c    ****     #elif  defined(INVERT_L_DIRECTION) && !defined(INVERT_R_DIRECTION)
 413:Src/util.c    ****       speedAvg    = (-rtY_Left.n_mot - rtY_Right.n_mot) / 2;
 414:Src/util.c    ****     #elif  defined(INVERT_L_DIRECTION) &&  defined(INVERT_R_DIRECTION)
 415:Src/util.c    ****       speedAvg    = (-rtY_Left.n_mot + rtY_Right.n_mot) / 2;
 416:Src/util.c    ****     #endif
 417:Src/util.c    **** 
 418:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
 419:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 420:Src/util.c    ****       speedAvg    = -speedAvg;
 421:Src/util.c    ****     } 
 422:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 454              		.loc 1 422 0
 455 001a 002B     		cmp	r3, #0
 456 001c B8BF     		it	lt
 457 001e 5B42     		rsblt	r3, r3, #0
 458 0020 044A     		ldr	r2, .L35+12
 459 0022 1380     		strh	r3, [r2]	@ movhi
 460 0024 7047     		bx	lr
 461              	.L36:
 462 0026 00BF     		.align	2
 463              	.L35:
 464 0028 00000000 		.word	rtY_Left
 465 002c 00000000 		.word	rtY_Right
 466 0030 00000000 		.word	speedAvg
 467 0034 00000000 		.word	speedAvgAbs
 468              		.cfi_endproc
 469              	.LFE72:
 471              		.section	.text.adcCalibLim,"ax",%progbits
 472              		.align	1
 473              		.global	adcCalibLim
 474              		.syntax unified
 475              		.thumb
 476              		.thumb_func
 477              		.fpu softvfp
 479              	adcCalibLim:
 480              	.LFB73:
 423:Src/util.c    **** }
 424:Src/util.c    **** 
 425:Src/util.c    ****  /*
 426:Src/util.c    ****  * Auto-calibration of the ADC Limits
 427:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 428:Src/util.c    ****  * Procedure:
 429:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 430:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
 431:Src/util.c    ****  * - release potentiometers to the resting postion
 432:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 433:Src/util.c    ****  */
 434:Src/util.c    **** void adcCalibLim(void) {
 481              		.loc 1 434 0
 482              		.cfi_startproc
 483              		@ args = 0, pretend = 0, frame = 0
 484              		@ frame_needed = 0, uses_anonymous_args = 0
 485              		@ link register save eliminated.
 486 0000 7047     		bx	lr
 487              		.cfi_endproc
ARM GAS  /tmp/ccCqBQUf.s 			page 17


 488              	.LFE73:
 490              		.section	.text.updateCurSpdLim,"ax",%progbits
 491              		.align	1
 492              		.global	updateCurSpdLim
 493              		.syntax unified
 494              		.thumb
 495              		.thumb_func
 496              		.fpu softvfp
 498              	updateCurSpdLim:
 499              	.LFB74:
 435:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 436:Src/util.c    ****     return;
 437:Src/util.c    ****   }
 438:Src/util.c    ****   #ifdef CONTROL_ADC
 439:Src/util.c    ****     consoleLog("ADC calibration started... ");
 440:Src/util.c    ****     
 441:Src/util.c    ****     // Inititalization: MIN = a high values, MAX = a low value,
 442:Src/util.c    ****     int32_t adc1_fixdt = adc_buffer.l_tx2 << 16;
 443:Src/util.c    ****     int32_t adc2_fixdt = adc_buffer.l_rx2 << 16;
 444:Src/util.c    ****     uint16_t adc_cal_timeout = 0;
 445:Src/util.c    ****     uint16_t ADC1_MIN_temp   = 4095;
 446:Src/util.c    ****     uint16_t ADC1_MID_temp   = 0;
 447:Src/util.c    ****     uint16_t ADC1_MAX_temp   = 0;
 448:Src/util.c    ****     uint16_t ADC2_MIN_temp   = 4095;
 449:Src/util.c    ****     uint16_t ADC2_MID_temp   = 0;
 450:Src/util.c    ****     uint16_t ADC2_MAX_temp   = 0;
 451:Src/util.c    ****     
 452:Src/util.c    ****     adc_cal_valid = 1;
 453:Src/util.c    **** 
 454:Src/util.c    ****     // Extract MIN, MAX and MID from ADC while the power button is not pressed
 455:Src/util.c    ****     while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && adc_cal_timeout++ < 4000) {   // 20 sec ti
 456:Src/util.c    ****       filtLowPass32(adc_buffer.l_tx2, FILTER, &adc1_fixdt);
 457:Src/util.c    ****       filtLowPass32(adc_buffer.l_rx2, FILTER, &adc2_fixdt);
 458:Src/util.c    ****       ADC1_MID_temp = (uint16_t)CLAMP(adc1_fixdt >> 16, 0, 4095);                   // convert fixe
 459:Src/util.c    ****       ADC2_MID_temp = (uint16_t)CLAMP(adc2_fixdt >> 16, 0, 4095);
 460:Src/util.c    ****       ADC1_MIN_temp = MIN(ADC1_MIN_temp, ADC1_MID_temp);
 461:Src/util.c    ****       ADC1_MAX_temp = MAX(ADC1_MAX_temp, ADC1_MID_temp);      
 462:Src/util.c    ****       ADC2_MIN_temp = MIN(ADC2_MIN_temp, ADC2_MID_temp);
 463:Src/util.c    ****       ADC2_MAX_temp = MAX(ADC2_MAX_temp, ADC2_MID_temp);
 464:Src/util.c    ****       HAL_Delay(5);
 465:Src/util.c    ****     }
 466:Src/util.c    **** 
 467:Src/util.c    ****     // ADC calibration checks 
 468:Src/util.c    ****     #ifdef ADC_PROTECT_ENA
 469:Src/util.c    ****     if ((ADC1_MIN_temp + 150 - ADC_PROTECT_THRESH) > 0 && (ADC1_MAX_temp - 150 + ADC_PROTECT_THRESH
 470:Src/util.c    ****         (ADC2_MIN_temp + 150 - ADC_PROTECT_THRESH) > 0 && (ADC2_MAX_temp - 150 + ADC_PROTECT_THRESH
 471:Src/util.c    ****       adc_cal_valid = 1;
 472:Src/util.c    ****     } else {
 473:Src/util.c    ****       adc_cal_valid = 0;
 474:Src/util.c    ****       consoleLog("FAIL (ADC out-of-range protection not possible)\n");
 475:Src/util.c    ****     }
 476:Src/util.c    ****     #endif
 477:Src/util.c    **** 
 478:Src/util.c    ****     // Add final ADC margin to have exact 0 and MAX at the minimum and maximum ADC value
 479:Src/util.c    ****     if (adc_cal_valid && (ADC1_MAX_temp - ADC1_MIN_temp) > 500 && (ADC2_MAX_temp - ADC2_MIN_temp) >
 480:Src/util.c    ****       ADC1_MIN_CAL = ADC1_MIN_temp + 150;
 481:Src/util.c    ****       ADC1_MID_CAL = ADC1_MID_temp;
ARM GAS  /tmp/ccCqBQUf.s 			page 18


 482:Src/util.c    ****       ADC1_MAX_CAL = ADC1_MAX_temp - 150;    
 483:Src/util.c    ****       ADC2_MIN_CAL = ADC2_MIN_temp + 150;
 484:Src/util.c    ****       ADC2_MID_CAL = ADC2_MID_temp;
 485:Src/util.c    ****       ADC2_MAX_CAL = ADC2_MAX_temp - 150;      
 486:Src/util.c    ****       consoleLog("OK\n");
 487:Src/util.c    ****     } else {
 488:Src/util.c    ****       adc_cal_valid = 0;
 489:Src/util.c    ****       consoleLog("FAIL (Pots travel too short)\n");
 490:Src/util.c    ****     }
 491:Src/util.c    **** 
 492:Src/util.c    ****   #endif
 493:Src/util.c    **** }
 494:Src/util.c    **** 
 495:Src/util.c    **** 
 496:Src/util.c    ****  /*
 497:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 498:Src/util.c    ****  * Procedure:
 499:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 500:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
 501:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 502:Src/util.c    ****  */
 503:Src/util.c    **** void updateCurSpdLim(void) {
 500              		.loc 1 503 0
 501              		.cfi_startproc
 502              		@ args = 0, pretend = 0, frame = 0
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              		@ link register save eliminated.
 505 0000 7047     		bx	lr
 506              		.cfi_endproc
 507              	.LFE74:
 509              		.section	.text.saveConfig,"ax",%progbits
 510              		.align	1
 511              		.global	saveConfig
 512              		.syntax unified
 513              		.thumb
 514              		.thumb_func
 515              		.fpu softvfp
 517              	saveConfig:
 518              	.LFB75:
 504:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 505:Src/util.c    ****     return;
 506:Src/util.c    ****   }
 507:Src/util.c    ****   #ifdef CONTROL_ADC
 508:Src/util.c    ****     consoleLog("Torque and Speed limits update started... ");
 509:Src/util.c    **** 
 510:Src/util.c    ****     int32_t adc1_fixdt = adc_buffer.l_tx2 << 16;
 511:Src/util.c    ****     int32_t adc2_fixdt = adc_buffer.l_rx2 << 16;
 512:Src/util.c    ****     uint16_t cur_spd_timeout = 0;
 513:Src/util.c    ****     uint16_t cur_factor;    // fixdt(0,16,16)
 514:Src/util.c    ****     uint16_t spd_factor;    // fixdt(0,16,16)
 515:Src/util.c    **** 
 516:Src/util.c    ****     // Wait for the power button press
 517:Src/util.c    ****     while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec tim
 518:Src/util.c    ****       filtLowPass32(adc_buffer.l_tx2, FILTER, &adc1_fixdt);
 519:Src/util.c    ****       filtLowPass32(adc_buffer.l_rx2, FILTER, &adc2_fixdt);
 520:Src/util.c    ****       HAL_Delay(5);      
 521:Src/util.c    ****     }
ARM GAS  /tmp/ccCqBQUf.s 			page 19


 522:Src/util.c    **** 
 523:Src/util.c    ****     // Calculate scaling factors
 524:Src/util.c    ****     cur_factor      = CLAMP((adc1_fixdt - (ADC1_MIN_CAL << 16)) / (ADC1_MAX_CAL - ADC1_MIN_CAL), 65
 525:Src/util.c    ****     spd_factor      = CLAMP((adc2_fixdt - (ADC2_MIN_CAL << 16)) / (ADC2_MAX_CAL - ADC2_MIN_CAL), 32
 526:Src/util.c    **** 
 527:Src/util.c    ****     // Update maximum limits
 528:Src/util.c    ****     rtP_Left.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    // fixdt(0,16,16) 
 529:Src/util.c    ****     rtP_Left.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 // fixdt(0,16,16) 
 530:Src/util.c    ****     rtP_Right.i_max = rtP_Left.i_max;
 531:Src/util.c    ****     rtP_Right.n_max = rtP_Left.n_max;
 532:Src/util.c    **** 
 533:Src/util.c    ****     cur_spd_valid   = 1;
 534:Src/util.c    ****     consoleLog("OK\n");
 535:Src/util.c    **** 
 536:Src/util.c    ****   #endif
 537:Src/util.c    **** }
 538:Src/util.c    **** 
 539:Src/util.c    ****  /*
 540:Src/util.c    ****  * Save Configuration to Flash
 541:Src/util.c    ****  * This function makes sure data is not lost after power-off
 542:Src/util.c    ****  */
 543:Src/util.c    **** void saveConfig() {
 519              		.loc 1 543 0
 520              		.cfi_startproc
 521              		@ args = 0, pretend = 0, frame = 0
 522              		@ frame_needed = 0, uses_anonymous_args = 0
 523              		@ link register save eliminated.
 524 0000 7047     		bx	lr
 525              		.cfi_endproc
 526              	.LFE75:
 528              		.section	.text.addDeadBand,"ax",%progbits
 529              		.align	1
 530              		.global	addDeadBand
 531              		.syntax unified
 532              		.thumb
 533              		.thumb_func
 534              		.fpu softvfp
 536              	addDeadBand:
 537              	.LFB76:
 544:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 545:Src/util.c    ****     if (saveValue_valid) {
 546:Src/util.c    ****       HAL_FLASH_Unlock();
 547:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
 548:Src/util.c    ****       HAL_FLASH_Lock();
 549:Src/util.c    ****     }
 550:Src/util.c    ****   #endif
 551:Src/util.c    ****   #ifdef CONTROL_ADC
 552:Src/util.c    ****     if (adc_cal_valid || cur_spd_valid) {
 553:Src/util.c    ****       HAL_FLASH_Unlock();
 554:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], FLASH_WRITE_KEY);
 555:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1], ADC1_MIN_CAL);
 556:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2], ADC1_MAX_CAL);
 557:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[3], ADC1_MID_CAL);
 558:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[4], ADC2_MIN_CAL);
 559:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[5], ADC2_MAX_CAL);
 560:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[6], ADC2_MID_CAL);
 561:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[7], rtP_Left.i_max);
ARM GAS  /tmp/ccCqBQUf.s 			page 20


 562:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[8], rtP_Left.n_max);
 563:Src/util.c    ****       HAL_FLASH_Lock();
 564:Src/util.c    ****     }
 565:Src/util.c    ****   #endif 
 566:Src/util.c    **** }
 567:Src/util.c    **** 
 568:Src/util.c    ****  /*
 569:Src/util.c    ****  * Add Dead-band to a signal
 570:Src/util.c    ****  * This function realizes a dead-band around 0 and scales the input between [out_min, out_max]
 571:Src/util.c    ****  */
 572:Src/util.c    **** int addDeadBand(int16_t u, int16_t deadBand, int16_t in_min, int16_t in_max, int16_t out_min, int16
 538              		.loc 1 572 0
 539              		.cfi_startproc
 540              		@ args = 8, pretend = 0, frame = 0
 541              		@ frame_needed = 0, uses_anonymous_args = 0
 542              		@ link register save eliminated.
 543              	.LVL24:
 573:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || defined
 574:Src/util.c    ****   int outVal = 0;
 575:Src/util.c    ****   if(u > -deadBand && u < deadBand) {
 576:Src/util.c    ****     outVal = 0;
 577:Src/util.c    ****   } else if(u > 0) {
 578:Src/util.c    ****     outVal = (out_max * CLAMP(u - deadBand, 0, in_max - deadBand)) / (in_max - deadBand);
 579:Src/util.c    ****   } else {
 580:Src/util.c    ****     outVal = (out_min * CLAMP(u + deadBand, in_min + deadBand, 0)) / (in_min + deadBand);
 581:Src/util.c    ****   }
 582:Src/util.c    ****   return outVal;
 583:Src/util.c    **** #else
 584:Src/util.c    ****   return 0;
 585:Src/util.c    **** #endif
 586:Src/util.c    **** }
 544              		.loc 1 586 0
 545 0000 0020     		movs	r0, #0
 546              	.LVL25:
 547 0002 7047     		bx	lr
 548              		.cfi_endproc
 549              	.LFE76:
 551              		.section	.text.standstillHold,"ax",%progbits
 552              		.align	1
 553              		.global	standstillHold
 554              		.syntax unified
 555              		.thumb
 556              		.thumb_func
 557              		.fpu softvfp
 559              	standstillHold:
 560              	.LFB77:
 587:Src/util.c    **** 
 588:Src/util.c    ****  /*
 589:Src/util.c    ****  * Standstill Hold Function
 590:Src/util.c    ****  * This function will switch to SPEED mode at standstill to provide an anti-roll functionality.
 591:Src/util.c    ****  * Only available and makes sense for VOLTAGE or TORQUE mode.
 592:Src/util.c    ****  * 
 593:Src/util.c    ****  * Input: pointer *speedCmd
 594:Src/util.c    ****  * Output: modified Control Mode Request
 595:Src/util.c    ****  */
 596:Src/util.c    **** void standstillHold(int16_t *speedCmd) {
 561              		.loc 1 596 0
ARM GAS  /tmp/ccCqBQUf.s 			page 21


 562              		.cfi_startproc
 563              		@ args = 0, pretend = 0, frame = 0
 564              		@ frame_needed = 0, uses_anonymous_args = 0
 565              		@ link register save eliminated.
 566              	.LVL26:
 567 0000 7047     		bx	lr
 568              		.cfi_endproc
 569              	.LFE77:
 571              		.section	.text.electricBrake,"ax",%progbits
 572              		.align	1
 573              		.global	electricBrake
 574              		.syntax unified
 575              		.thumb
 576              		.thumb_func
 577              		.fpu softvfp
 579              	electricBrake:
 580              	.LFB78:
 597:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
 598:Src/util.c    ****     if (*speedCmd > -20 && *speedCmd < 20) {                          // If speedCmd (Throttle) is 
 599:Src/util.c    ****       if (ctrlModReqRaw != SPD_MODE && speedAvgAbs < 3) {             // and If measured speed is s
 600:Src/util.c    ****         ctrlModReqRaw = SPD_MODE;                                     // Switch to Speed mode
 601:Src/util.c    ****       }
 602:Src/util.c    ****       if (ctrlModReqRaw == SPD_MODE) {                                // If we are in Speed mode
 603:Src/util.c    ****         *speedCmd = 0;                                                // Request standstill (0 rpm)
 604:Src/util.c    ****       }
 605:Src/util.c    ****     } else if (ctrlModReqRaw != CTRL_MOD_REQ && (*speedCmd < -50 || *speedCmd > 50)) { // Else if s
 606:Src/util.c    ****       ctrlModReqRaw = CTRL_MOD_REQ;                                   // Follow the Mode request
 607:Src/util.c    ****     }
 608:Src/util.c    ****   #endif
 609:Src/util.c    **** }
 610:Src/util.c    **** 
 611:Src/util.c    ****  /*
 612:Src/util.c    ****  * Electric Brake Function
 613:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 614:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 615:Src/util.c    ****  * 
 616:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 617:Src/util.c    ****  * Output: cmd2 (Throtle) with brake component included
 618:Src/util.c    ****  */
 619:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 581              		.loc 1 619 0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 0
 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              		@ link register save eliminated.
 586              	.LVL27:
 587 0000 7047     		bx	lr
 588              		.cfi_endproc
 589              	.LFE78:
 591              		.section	.text.poweroff,"ax",%progbits
 592              		.align	1
 593              		.global	poweroff
 594              		.syntax unified
 595              		.thumb
 596              		.thumb_func
 597              		.fpu softvfp
 599              	poweroff:
ARM GAS  /tmp/ccCqBQUf.s 			page 22


 600              	.LFB79:
 620:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 621:Src/util.c    ****     int16_t brakeVal;
 622:Src/util.c    **** 
 623:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 624:Src/util.c    ****     if (speedAvg > 0) {
 625:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 626:Src/util.c    ****     } else {
 627:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);          
 628:Src/util.c    ****     }
 629:Src/util.c    **** 
 630:Src/util.c    ****     // Check if direction is reversed
 631:Src/util.c    ****     if (reverseDir) {
 632:Src/util.c    ****       brakeVal = -brakeVal;
 633:Src/util.c    ****     }
 634:Src/util.c    **** 
 635:Src/util.c    ****     // Calculate the new cmd2 with brake component included
 636:Src/util.c    ****     if (cmd2 >= 0 && cmd2 < ELECTRIC_BRAKE_THRES) {
 637:Src/util.c    ****       cmd2 = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - cmd2) * brakeVal) / ELECTRIC_BRAKE_THRES);
 638:Src/util.c    ****     } else if (cmd2 >= -ELECTRIC_BRAKE_THRES && cmd2 < 0) {
 639:Src/util.c    ****       cmd2 = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + cmd2) * brakeVal) / ELECTRIC_BRAKE_THRES);
 640:Src/util.c    ****     } else if (cmd2 >= ELECTRIC_BRAKE_THRES) {
 641:Src/util.c    ****       cmd2 = MAX(brakeVal, ((cmd2 - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / (INPUT_MAX - ELECTRIC_BRAK
 642:Src/util.c    ****     } else {  // when (cmd2 < -ELECTRIC_BRAKE_THRES)
 643:Src/util.c    ****       cmd2 = MIN(brakeVal, ((cmd2 + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / (INPUT_MIN + ELECTRIC_BRAK
 644:Src/util.c    ****     }
 645:Src/util.c    ****   #endif
 646:Src/util.c    **** }
 647:Src/util.c    **** 
 648:Src/util.c    **** 
 649:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
 650:Src/util.c    **** 
 651:Src/util.c    **** void poweroff(void) {
 601              		.loc 1 651 0
 602              		.cfi_startproc
 603              		@ args = 0, pretend = 0, frame = 0
 604              		@ frame_needed = 0, uses_anonymous_args = 0
 605              		.loc 1 651 0
 606 0000 10B5     		push	{r4, lr}
 607              	.LCFI6:
 608              		.cfi_def_cfa_offset 8
 609              		.cfi_offset 4, -8
 610              		.cfi_offset 14, -4
 652:Src/util.c    **** 	buzzerPattern = 0;
 611              		.loc 1 652 0
 612 0002 0024     		movs	r4, #0
 613 0004 0A4B     		ldr	r3, .L48
 614 0006 1C70     		strb	r4, [r3]
 653:Src/util.c    **** 	enable = 0;
 615              		.loc 1 653 0
 616 0008 0A4B     		ldr	r3, .L48+4
 617 000a 1C70     		strb	r4, [r3]
 654:Src/util.c    **** 	consoleLog("-- Motors disabled --\r\n");
 618              		.loc 1 654 0
 619 000c 0A48     		ldr	r0, .L48+8
 620 000e FFF7FEFF 		bl	consoleLog
 621              	.LVL28:
ARM GAS  /tmp/ccCqBQUf.s 			page 23


 622              	.LBB4:
 655:Src/util.c    **** 	for (int i = 0; i < 8; i++) {
 623              		.loc 1 655 0
 624 0012 05E0     		b	.L44
 625              	.LVL29:
 626              	.L45:
 656:Src/util.c    **** 		buzzerFreq = (uint8_t)i;
 627              		.loc 1 656 0 discriminator 3
 628 0014 094B     		ldr	r3, .L48+12
 629 0016 1C70     		strb	r4, [r3]
 657:Src/util.c    **** 		HAL_Delay(100);
 630              		.loc 1 657 0 discriminator 3
 631 0018 6420     		movs	r0, #100
 632 001a FFF7FEFF 		bl	HAL_Delay
 633              	.LVL30:
 655:Src/util.c    **** 	for (int i = 0; i < 8; i++) {
 634              		.loc 1 655 0 discriminator 3
 635 001e 0134     		adds	r4, r4, #1
 636              	.LVL31:
 637              	.L44:
 655:Src/util.c    **** 	for (int i = 0; i < 8; i++) {
 638              		.loc 1 655 0 is_stmt 0 discriminator 1
 639 0020 072C     		cmp	r4, #7
 640 0022 F7DD     		ble	.L45
 641              	.LBE4:
 658:Src/util.c    **** 	}
 659:Src/util.c    ****   saveConfig();
 660:Src/util.c    **** 	HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 642              		.loc 1 660 0 is_stmt 1
 643 0024 0022     		movs	r2, #0
 644 0026 2021     		movs	r1, #32
 645 0028 0548     		ldr	r0, .L48+16
 646 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
 647              	.LVL32:
 648              	.L46:
 649 002e FEE7     		b	.L46
 650              	.L49:
 651              		.align	2
 652              	.L48:
 653 0030 00000000 		.word	buzzerPattern
 654 0034 00000000 		.word	enable
 655 0038 00000000 		.word	.LC0
 656 003c 00000000 		.word	buzzerFreq
 657 0040 00080140 		.word	1073809408
 658              		.cfi_endproc
 659              	.LFE79:
 661              		.section	.text.poweroffPressCheck,"ax",%progbits
 662              		.align	1
 663              		.global	poweroffPressCheck
 664              		.syntax unified
 665              		.thumb
 666              		.thumb_func
 667              		.fpu softvfp
 669              	poweroffPressCheck:
 670              	.LFB80:
 661:Src/util.c    **** 	while(1) {}
 662:Src/util.c    **** }
ARM GAS  /tmp/ccCqBQUf.s 			page 24


 663:Src/util.c    **** 
 664:Src/util.c    **** 
 665:Src/util.c    **** void poweroffPressCheck(void) {
 671              		.loc 1 665 0
 672              		.cfi_startproc
 673              		@ args = 0, pretend = 0, frame = 0
 674              		@ frame_needed = 0, uses_anonymous_args = 0
 675 0000 08B5     		push	{r3, lr}
 676              	.LCFI7:
 677              		.cfi_def_cfa_offset 8
 678              		.cfi_offset 3, -8
 679              		.cfi_offset 14, -4
 666:Src/util.c    **** 	#if defined(CONTROL_ADC)
 667:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 668:Src/util.c    ****       enable = 0;
 669:Src/util.c    ****       uint16_t cnt_press = 0;
 670:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 671:Src/util.c    ****         HAL_Delay(10);
 672:Src/util.c    ****         if (cnt_press++ == 5 * 100) { shortBeep(5); }          
 673:Src/util.c    ****       }
 674:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
 675:Src/util.c    ****         HAL_Delay(300);        
 676:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 677:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }  
 678:Src/util.c    ****           longBeep(8);
 679:Src/util.c    ****           updateCurSpdLim();
 680:Src/util.c    ****           shortBeep(5);
 681:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 682:Src/util.c    ****           longBeep(16); 
 683:Src/util.c    ****           adcCalibLim();
 684:Src/util.c    ****           shortBeep(5);
 685:Src/util.c    ****         }
 686:Src/util.c    ****       } else {                                            // Short press: power off
 687:Src/util.c    ****         poweroff();
 688:Src/util.c    ****       }
 689:Src/util.c    ****     }
 690:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
 691:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 692:Src/util.c    ****       enable = 0;
 693:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 694:Src/util.c    ****       shortBeep(5);
 695:Src/util.c    ****       HAL_Delay(300);
 696:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 697:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 698:Src/util.c    ****         longBeep(5);
 699:Src/util.c    ****         HAL_Delay(350);
 700:Src/util.c    ****         poweroff();
 701:Src/util.c    ****       } else {
 702:Src/util.c    ****         setDistance += 0.25;
 703:Src/util.c    ****         if (setDistance > 2.6) {
 704:Src/util.c    ****           setDistance = 0.5;
 705:Src/util.c    ****         }
 706:Src/util.c    ****         shortBeep(setDistance / 0.25);
 707:Src/util.c    ****         saveValue = setDistance * 1000;
 708:Src/util.c    ****         saveValue_valid = 1;
 709:Src/util.c    ****       }
 710:Src/util.c    ****     }
ARM GAS  /tmp/ccCqBQUf.s 			page 25


 711:Src/util.c    ****   #else
 712:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 680              		.loc 1 712 0
 681 0002 0221     		movs	r1, #2
 682 0004 0748     		ldr	r0, .L55
 683 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 684              	.LVL33:
 685 000a 00B9     		cbnz	r0, .L54
 686 000c 08BD     		pop	{r3, pc}
 687              	.L54:
 713:Src/util.c    ****       enable = 0;                                             // disable motors
 688              		.loc 1 713 0
 689 000e 0022     		movs	r2, #0
 690 0010 054B     		ldr	r3, .L55+4
 691 0012 1A70     		strb	r2, [r3]
 692              	.L52:
 714:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
 693              		.loc 1 714 0 discriminator 1
 694 0014 0221     		movs	r1, #2
 695 0016 0348     		ldr	r0, .L55
 696 0018 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 697              	.LVL34:
 698 001c 0028     		cmp	r0, #0
 699 001e F9D1     		bne	.L52
 715:Src/util.c    ****       poweroff();                                             // release power-latch
 700              		.loc 1 715 0
 701 0020 FFF7FEFF 		bl	poweroff
 702              	.LVL35:
 703              	.L56:
 704              		.align	2
 705              	.L55:
 706 0024 00080140 		.word	1073809408
 707 0028 00000000 		.word	enable
 708              		.cfi_endproc
 709              	.LFE80:
 711              		.section	.text.readCommand,"ax",%progbits
 712              		.align	1
 713              		.global	readCommand
 714              		.syntax unified
 715              		.thumb
 716              		.thumb_func
 717              		.fpu softvfp
 719              	readCommand:
 720              	.LFB81:
 716:Src/util.c    ****     }
 717:Src/util.c    ****   #endif
 718:Src/util.c    **** }
 719:Src/util.c    **** 
 720:Src/util.c    **** 
 721:Src/util.c    **** 
 722:Src/util.c    **** /* =========================== Read Command Function =========================== */
 723:Src/util.c    **** 
 724:Src/util.c    **** void readCommand(void) {
 721              		.loc 1 724 0
 722              		.cfi_startproc
 723              		@ args = 0, pretend = 0, frame = 0
 724              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccCqBQUf.s 			page 26


 725              		@ link register save eliminated.
 725:Src/util.c    **** 
 726:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 727:Src/util.c    ****       if (nunchuk_connected != 0) {
 728:Src/util.c    ****         Nunchuk_Read();
 729:Src/util.c    ****         cmd1 = CLAMP((nunchuk_data[0] - 127) * 8, INPUT_MIN, INPUT_MAX); // x - axis. Nunchuk joyst
 730:Src/util.c    ****         cmd2 = CLAMP((nunchuk_data[1] - 128) * 8, INPUT_MIN, INPUT_MAX); // y - axis
 731:Src/util.c    **** 				
 732:Src/util.c    **** 				#ifdef SUPPORT_BUTTONS
 733:Src/util.c    **** 					button1 = (uint8_t)nunchuk_data[5] & 1;
 734:Src/util.c    **** 					button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
 735:Src/util.c    **** 				#endif
 736:Src/util.c    ****       }
 737:Src/util.c    ****     #endif
 738:Src/util.c    **** 
 739:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 740:Src/util.c    ****       cmd1 = addDeadBand((ppm_captured_value[0] - 500) * 2, PPM_DEADBAND, PPM_CH1_MIN, PPM_CH1_MAX,
 741:Src/util.c    ****       cmd2 = addDeadBand((ppm_captured_value[1] - 500) * 2, PPM_DEADBAND, PPM_CH2_MIN, PPM_CH2_MAX,
 742:Src/util.c    **** 			#ifdef SUPPORT_BUTTONS
 743:Src/util.c    **** 				button1 = ppm_captured_value[5] > 500;
 744:Src/util.c    **** 				button2 = 0;
 745:Src/util.c    ****       #elif defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 746:Src/util.c    ****         button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
 747:Src/util.c    ****         button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
 748:Src/util.c    **** 			#endif
 749:Src/util.c    ****       // float scale = ppm_captured_value[2] / 1000.0f;     // not used for now, uncomment if neede
 750:Src/util.c    ****     #endif
 751:Src/util.c    **** 
 752:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 753:Src/util.c    ****       cmd1 = addDeadBand((pwm_captured_ch1_value - 500) * 2, PWM_DEADBAND, PWM_CH1_MIN, PWM_CH1_MAX
 754:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
 755:Src/util.c    ****       cmd2 = addDeadBand((pwm_captured_ch2_value - 500) * 2, PWM_DEADBAND, PWM_CH2_MIN, PWM_CH2_MAX
 756:Src/util.c    ****       #else      
 757:Src/util.c    ****       cmd2 = addDeadBand((pwm_captured_ch2_value - 500) * 2, PWM_DEADBAND, PWM_CH2_MIN, PWM_CH2_MAX
 758:Src/util.c    ****       #endif
 759:Src/util.c    ****       #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 760:Src/util.c    ****         button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
 761:Src/util.c    ****         button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
 762:Src/util.c    ****       #endif
 763:Src/util.c    ****     #endif
 764:Src/util.c    **** 
 765:Src/util.c    ****     #ifdef CONTROL_ADC
 766:Src/util.c    ****       // ADC values range: 0-4095, see ADC-calibration in config.h
 767:Src/util.c    ****       #ifdef ADC1_MID_POT
 768:Src/util.c    ****         cmd1 = CLAMP((adc_buffer.l_tx2 - ADC1_MID_CAL) * INPUT_MAX / (ADC1_MAX_CAL - ADC1_MID_CAL),
 769:Src/util.c    ****               +CLAMP((ADC1_MID_CAL - adc_buffer.l_tx2) * INPUT_MIN / (ADC1_MID_CAL - ADC1_MIN_CAL),
 770:Src/util.c    ****       #else
 771:Src/util.c    ****         cmd1 = CLAMP((adc_buffer.l_tx2 - ADC1_MIN_CAL) * INPUT_MAX / (ADC1_MAX_CAL - ADC1_MIN_CAL),
 772:Src/util.c    ****       #endif
 773:Src/util.c    **** 
 774:Src/util.c    ****       #ifdef ADC2_MID_POT
 775:Src/util.c    ****         cmd2 = CLAMP((adc_buffer.l_rx2 - ADC2_MID_CAL) * INPUT_MAX / (ADC2_MAX_CAL - ADC2_MID_CAL),
 776:Src/util.c    ****               +CLAMP((ADC2_MID_CAL - adc_buffer.l_rx2) * INPUT_MIN / (ADC2_MID_CAL - ADC2_MIN_CAL),
 777:Src/util.c    ****       #else
 778:Src/util.c    ****         cmd2 = CLAMP((adc_buffer.l_rx2 - ADC2_MIN_CAL) * INPUT_MAX / (ADC2_MAX_CAL - ADC2_MIN_CAL),
 779:Src/util.c    ****       #endif
 780:Src/util.c    **** 
ARM GAS  /tmp/ccCqBQUf.s 			page 27


 781:Src/util.c    ****       #ifdef ADC_PROTECT_ENA
 782:Src/util.c    ****         if (adc_buffer.l_tx2 >= (ADC1_MIN_CAL - ADC_PROTECT_THRESH) && adc_buffer.l_tx2 <= (ADC1_MA
 783:Src/util.c    ****             adc_buffer.l_rx2 >= (ADC2_MIN_CAL - ADC_PROTECT_THRESH) && adc_buffer.l_rx2 <= (ADC2_MA
 784:Src/util.c    ****           if (timeoutFlagADC) {                         // Check for previous timeout flag  
 785:Src/util.c    ****             if (timeoutCntADC-- <= 0)                   // Timeout de-qualification
 786:Src/util.c    ****               timeoutFlagADC  = 0;                      // Timeout flag cleared           
 787:Src/util.c    ****           } else {
 788:Src/util.c    ****             timeoutCntADC     = 0;                      // Reset the timeout counter         
 789:Src/util.c    ****           }
 790:Src/util.c    ****         } else {
 791:Src/util.c    ****           if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) { // Timeout qualification
 792:Src/util.c    ****             timeoutFlagADC    = 1;                      // Timeout detected
 793:Src/util.c    ****             timeoutCntADC     = ADC_PROTECT_TIMEOUT;    // Limit timout counter value
 794:Src/util.c    ****           }
 795:Src/util.c    ****         }   
 796:Src/util.c    ****       #endif
 797:Src/util.c    **** 
 798:Src/util.c    ****       #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 799:Src/util.c    ****         button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
 800:Src/util.c    ****         button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
 801:Src/util.c    ****       #endif
 802:Src/util.c    ****       timeoutCnt = 0;
 803:Src/util.c    ****     #endif
 804:Src/util.c    **** 
 805:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
 806:Src/util.c    ****         // Handle received data validity, timeout and fix out-of-sync if necessary
 807:Src/util.c    ****       #ifdef CONTROL_IBUS    
 808:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 809:Src/util.c    ****           ibus_captured_value[(i/2)] = CLAMP(command.channels[i] + (command.channels[i+1] << 8) - 1
 810:Src/util.c    ****         }
 811:Src/util.c    ****         cmd1 = CLAMP((ibus_captured_value[0] - 500) * 2, INPUT_MIN, INPUT_MAX);
 812:Src/util.c    ****         cmd2 = CLAMP((ibus_captured_value[1] - 500) * 2, INPUT_MIN, INPUT_MAX); 
 813:Src/util.c    ****       #else
 814:Src/util.c    ****        if (IN_RANGE(command.steer, INPUT_MIN, INPUT_MAX) && IN_RANGE(command.speed, INPUT_MIN, INPU
 726              		.loc 1 814 0
 727 0000 1F4B     		ldr	r3, .L63
 728 0002 B3F90230 		ldrsh	r3, [r3, #2]
 729 0006 1F4A     		ldr	r2, .L63+4
 730 0008 B2F90020 		ldrsh	r2, [r2]
 731 000c 9342     		cmp	r3, r2
 732 000e 0FDB     		blt	.L58
 733              		.loc 1 814 0 is_stmt 0 discriminator 1
 734 0010 1D49     		ldr	r1, .L63+8
 735 0012 B1F90010 		ldrsh	r1, [r1]
 736 0016 8B42     		cmp	r3, r1
 737 0018 0ADC     		bgt	.L58
 738              		.loc 1 814 0 discriminator 2
 739 001a 1948     		ldr	r0, .L63
 740 001c B0F90400 		ldrsh	r0, [r0, #4]
 741 0020 8242     		cmp	r2, r0
 742 0022 05DC     		bgt	.L58
 743              		.loc 1 814 0 discriminator 3
 744 0024 8142     		cmp	r1, r0
 745 0026 03DB     		blt	.L58
 815:Src/util.c    ****         cmd1 = command.steer;
 746              		.loc 1 815 0 is_stmt 1
 747 0028 184A     		ldr	r2, .L63+12
ARM GAS  /tmp/ccCqBQUf.s 			page 28


 748 002a 1380     		strh	r3, [r2]	@ movhi
 816:Src/util.c    ****         cmd2 = command.speed;
 749              		.loc 1 816 0
 750 002c 184B     		ldr	r3, .L63+16
 751 002e 1880     		strh	r0, [r3]	@ movhi
 752              	.L58:
 817:Src/util.c    ****        }
 818:Src/util.c    ****       #endif
 819:Src/util.c    **** 
 820:Src/util.c    ****       #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 821:Src/util.c    ****         button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
 822:Src/util.c    ****         button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
 823:Src/util.c    ****       #endif
 824:Src/util.c    ****       timeoutCnt = 0;
 753              		.loc 1 824 0
 754 0030 0022     		movs	r2, #0
 755 0032 184B     		ldr	r3, .L63+20
 756 0034 1A60     		str	r2, [r3]
 825:Src/util.c    ****     #endif
 826:Src/util.c    **** 
 827:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 828:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 829:Src/util.c    ****         timeoutFlagSerial_L = 1;                        // Timeout detected
 830:Src/util.c    ****         timeoutCntSerial_L  = SERIAL_TIMEOUT;           // Limit timout counter value
 831:Src/util.c    ****       }
 832:Src/util.c    ****       timeoutFlagSerial = timeoutFlagSerial_L;
 833:Src/util.c    ****     #endif
 834:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 835:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 757              		.loc 1 835 0
 758 0036 184A     		ldr	r2, .L63+24
 759 0038 1388     		ldrh	r3, [r2]
 760 003a 591C     		adds	r1, r3, #1
 761 003c 1180     		strh	r1, [r2]	@ movhi
 762 003e 9F2B     		cmp	r3, #159
 763 0040 05D9     		bls	.L59
 836:Src/util.c    ****         timeoutFlagSerial_R = 1;                        // Timeout detected
 764              		.loc 1 836 0
 765 0042 0122     		movs	r2, #1
 766 0044 154B     		ldr	r3, .L63+28
 767 0046 1A70     		strb	r2, [r3]
 837:Src/util.c    ****         timeoutCntSerial_R  = SERIAL_TIMEOUT;           // Limit timout counter value
 768              		.loc 1 837 0
 769 0048 A022     		movs	r2, #160
 770 004a 134B     		ldr	r3, .L63+24
 771 004c 1A80     		strh	r2, [r3]	@ movhi
 772              	.L59:
 838:Src/util.c    ****       }
 839:Src/util.c    ****       timeoutFlagSerial = timeoutFlagSerial_R;
 773              		.loc 1 839 0
 774 004e 134B     		ldr	r3, .L63+28
 775 0050 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 776 0052 134A     		ldr	r2, .L63+32
 777 0054 1370     		strb	r3, [r2]
 840:Src/util.c    ****     #endif
 841:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
 842:Src/util.c    ****       timeoutFlagSerial = timeoutFlagSerial_L || timeoutFlagSerial_R;
ARM GAS  /tmp/ccCqBQUf.s 			page 29


 843:Src/util.c    ****     #endif
 844:Src/util.c    **** 
 845:Src/util.c    ****     #ifdef VARIANT_HOVERCAR      
 846:Src/util.c    ****       brakePressed = (uint8_t)(cmd1 > 50);
 847:Src/util.c    ****     #endif
 848:Src/util.c    **** 
 849:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 850:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 851:Src/util.c    ****         cmd1 = adc_buffer.l_rx2;
 852:Src/util.c    ****         cmd2 = adc_buffer.l_tx2;
 853:Src/util.c    ****       #endif
 854:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 855:Src/util.c    ****         cmd1 = adc_buffer.l_tx2;
 856:Src/util.c    ****         cmd2 = adc_buffer.l_rx2;
 857:Src/util.c    ****       #endif
 858:Src/util.c    ****     #endif
 859:Src/util.c    **** 
 860:Src/util.c    ****     if (timeoutFlagADC || timeoutFlagSerial || timeoutCnt > TIMEOUT) {  // In case of timeout bring
 778              		.loc 1 860 0
 779 0056 134A     		ldr	r2, .L63+36
 780 0058 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 781 005a 4AB9     		cbnz	r2, .L60
 782              		.loc 1 860 0 is_stmt 0 discriminator 1
 783 005c 43B9     		cbnz	r3, .L60
 784              		.loc 1 860 0 discriminator 2
 785 005e 0D4B     		ldr	r3, .L63+20
 786 0060 1B68     		ldr	r3, [r3]
 787 0062 142B     		cmp	r3, #20
 788 0064 04D8     		bhi	.L60
 861:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 862:Src/util.c    ****       cmd1        = 0;
 863:Src/util.c    ****       cmd2        = 0;
 864:Src/util.c    ****     } else {
 865:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
 789              		.loc 1 865 0 is_stmt 1
 790 0066 104B     		ldr	r3, .L63+40
 791 0068 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 792 006a 104B     		ldr	r3, .L63+44
 793 006c 1A70     		strb	r2, [r3]
 794 006e 7047     		bx	lr
 795              	.L60:
 861:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 796              		.loc 1 861 0
 797 0070 0023     		movs	r3, #0
 798 0072 0E4A     		ldr	r2, .L63+44
 799 0074 1370     		strb	r3, [r2]
 862:Src/util.c    ****       cmd2        = 0;
 800              		.loc 1 862 0
 801 0076 054A     		ldr	r2, .L63+12
 802 0078 1380     		strh	r3, [r2]	@ movhi
 863:Src/util.c    ****     } else {
 803              		.loc 1 863 0
 804 007a 054A     		ldr	r2, .L63+16
 805 007c 1380     		strh	r3, [r2]	@ movhi
 806 007e 7047     		bx	lr
 807              	.L64:
 808              		.align	2
ARM GAS  /tmp/ccCqBQUf.s 			page 30


 809              	.L63:
 810 0080 00000000 		.word	.LANCHOR3
 811 0084 00000000 		.word	.LANCHOR1
 812 0088 00000000 		.word	.LANCHOR0
 813 008c 00000000 		.word	cmd1
 814 0090 00000000 		.word	cmd2
 815 0094 00000000 		.word	timeoutCnt
 816 0098 00000000 		.word	.LANCHOR4
 817 009c 00000000 		.word	.LANCHOR5
 818 00a0 00000000 		.word	.LANCHOR6
 819 00a4 00000000 		.word	.LANCHOR7
 820 00a8 00000000 		.word	.LANCHOR9
 821 00ac 00000000 		.word	.LANCHOR8
 822              		.cfi_endproc
 823              	.LFE81:
 825              		.section	.text.usart2_rx_check,"ax",%progbits
 826              		.align	1
 827              		.global	usart2_rx_check
 828              		.syntax unified
 829              		.thumb
 830              		.thumb_func
 831              		.fpu softvfp
 833              	usart2_rx_check:
 834              	.LFB82:
 866:Src/util.c    ****     }
 867:Src/util.c    **** 
 868:Src/util.c    **** }
 869:Src/util.c    **** 
 870:Src/util.c    **** 
 871:Src/util.c    **** /*
 872:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
 873:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 874:Src/util.c    ****  */
 875:Src/util.c    **** void usart2_rx_check(void)
 876:Src/util.c    **** {
 835              		.loc 1 876 0
 836              		.cfi_startproc
 837              		@ args = 0, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 839              		@ link register save eliminated.
 840 0000 7047     		bx	lr
 841              		.cfi_endproc
 842              	.LFE82:
 844              		.section	.text.usart_process_command,"ax",%progbits
 845              		.align	1
 846              		.global	usart_process_command
 847              		.syntax unified
 848              		.thumb
 849              		.thumb_func
 850              		.fpu softvfp
 852              	usart_process_command:
 853              	.LFB84:
 877:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 878:Src/util.c    ****   static uint32_t old_pos;
 879:Src/util.c    ****   uint32_t pos;
 880:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
 881:Src/util.c    ****   #endif
ARM GAS  /tmp/ccCqBQUf.s 			page 31


 882:Src/util.c    **** 
 883:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
 884:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 885:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
 886:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
 887:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
 888:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], rx_buffer_L_len - old_pos); // First Process data 
 889:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 890:Src/util.c    ****         usart_process_debug(&rx_buffer_L[0], pos);                      // Process remaining data 	
 891:Src/util.c    ****       }
 892:Src/util.c    ****     }
 893:Src/util.c    ****   }
 894:Src/util.c    **** 	#endif // DEBUG_SERIAL_USART2
 895:Src/util.c    **** 
 896:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
 897:Src/util.c    ****   uint8_t *ptr;	
 898:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 899:Src/util.c    ****     ptr = (uint8_t *)&command_raw;                                      // Initialize the pointer w
 900:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == command_len) {              // "Linear" buffer mode: ch
 901:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], command_len);                  // Copy data. This is possi
 902:Src/util.c    ****       usart_process_command(&command_raw, &command, 2);                 // Process data
 903:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == command_len) {      // "Overflow" buffer mode: 
 904:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 905:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 906:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
 907:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
 908:Src/util.c    ****       }
 909:Src/util.c    ****       usart_process_command(&command_raw, &command, 2);                 // Process data
 910:Src/util.c    ****     }
 911:Src/util.c    ****   }
 912:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
 913:Src/util.c    **** 
 914:Src/util.c    **** 	#ifdef SIDEBOARD_SERIAL_USART2
 915:Src/util.c    ****   uint8_t *ptr;	
 916:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 917:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
 918:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
 919:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
 920:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
 921:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
 922:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 923:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 924:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
 925:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
 926:Src/util.c    ****       }
 927:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
 928:Src/util.c    ****     }
 929:Src/util.c    ****   }
 930:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
 931:Src/util.c    **** 
 932:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 933:Src/util.c    ****   old_pos = pos;                                                        // Update old position
 934:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
 935:Src/util.c    ****     old_pos = 0;
 936:Src/util.c    ****   }
 937:Src/util.c    **** 	#endif
 938:Src/util.c    **** }
ARM GAS  /tmp/ccCqBQUf.s 			page 32


 939:Src/util.c    **** 
 940:Src/util.c    **** 
 941:Src/util.c    **** /*
 942:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
 943:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
 944:Src/util.c    ****  */
 945:Src/util.c    **** void usart3_rx_check(void)
 946:Src/util.c    **** {
 947:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 948:Src/util.c    ****   static uint32_t old_pos;
 949:Src/util.c    ****   uint32_t pos;  
 950:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
 951:Src/util.c    ****   #endif
 952:Src/util.c    **** 
 953:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
 954:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 955:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
 956:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
 957:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
 958:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], rx_buffer_R_len - old_pos); // First Process data 
 959:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 960:Src/util.c    ****         usart_process_debug(&rx_buffer_R[0], pos);                      // Process remaining data 	
 961:Src/util.c    ****       }
 962:Src/util.c    ****     }
 963:Src/util.c    ****   }
 964:Src/util.c    **** 	#endif // DEBUG_SERIAL_USART3
 965:Src/util.c    **** 
 966:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
 967:Src/util.c    ****   uint8_t *ptr;	
 968:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 969:Src/util.c    ****     ptr = (uint8_t *)&command_raw;                                      // Initialize the pointer w
 970:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == command_len) {              // "Linear" buffer mode: ch
 971:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], command_len);                  // Copy data. This is possi
 972:Src/util.c    ****       usart_process_command(&command_raw, &command, 3);                 // Process data
 973:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == command_len) {      // "Overflow" buffer mode: 
 974:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 975:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 976:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
 977:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
 978:Src/util.c    ****       }
 979:Src/util.c    ****       usart_process_command(&command_raw, &command, 3);                 // Process data
 980:Src/util.c    ****     }
 981:Src/util.c    ****   }
 982:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
 983:Src/util.c    **** 
 984:Src/util.c    **** 	#ifdef SIDEBOARD_SERIAL_USART3
 985:Src/util.c    ****   uint8_t *ptr;
 986:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 987:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
 988:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
 989:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
 990:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
 991:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
 992:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 993:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 994:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
 995:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
ARM GAS  /tmp/ccCqBQUf.s 			page 33


 996:Src/util.c    ****       }
 997:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
 998:Src/util.c    ****     }
 999:Src/util.c    ****   }
1000:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1001:Src/util.c    **** 
1002:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1003:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1004:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
1005:Src/util.c    ****     old_pos = 0;
1006:Src/util.c    ****   }
1007:Src/util.c    **** 	#endif
1008:Src/util.c    **** }
1009:Src/util.c    **** 
1010:Src/util.c    **** /*
1011:Src/util.c    ****  * Process Rx debug user command input
1012:Src/util.c    ****  */
1013:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1014:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
1015:Src/util.c    **** {
1016:Src/util.c    **** 	for (; len > 0; len--, userCommand++) {
1017:Src/util.c    **** 		if (*userCommand != '\n' && *userCommand != '\r') { 	// Do not accept 'new line' and 'carriage re
1018:Src/util.c    ****       consoleLog("-- Command received --\r\n");						
1019:Src/util.c    **** 			// handle_input(*userCommand);                      // -> Create this function to handle the use
1020:Src/util.c    **** 		}
1021:Src/util.c    ****   }
1022:Src/util.c    **** }
1023:Src/util.c    **** #endif // SERIAL_DEBUG
1024:Src/util.c    **** 
1025:Src/util.c    **** /*
1026:Src/util.c    ****  * Process command Rx data
1027:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1028:Src/util.c    ****  */
1029:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1030:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1031:Src/util.c    **** {
 854              		.loc 1 1031 0
 855              		.cfi_startproc
 856              		@ args = 0, pretend = 0, frame = 0
 857              		@ frame_needed = 0, uses_anonymous_args = 0
 858              		@ link register save eliminated.
 859              	.LVL36:
 860              		.loc 1 1031 0
 861 0000 10B4     		push	{r4}
 862              	.LCFI8:
 863              		.cfi_def_cfa_offset 4
 864              		.cfi_offset 4, -4
1032:Src/util.c    ****   #ifdef CONTROL_IBUS
1033:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1034:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1035:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1036:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1037:Src/util.c    ****       }
1038:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1039:Src/util.c    ****         *command_out = *command_in;
1040:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1041:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
ARM GAS  /tmp/ccCqBQUf.s 			page 34


1042:Src/util.c    ****           timeoutCntSerial_L  = 0;        // Reset timeout counter
1043:Src/util.c    ****           timeoutFlagSerial_L = 0;        // Clear timeout flag
1044:Src/util.c    ****           #endif
1045:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1046:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1047:Src/util.c    ****           timeoutCntSerial_R  = 0;        // Reset timeout counter
1048:Src/util.c    ****           timeoutFlagSerial_R = 0;        // Clear timeout flag
1049:Src/util.c    ****           #endif
1050:Src/util.c    ****         }
1051:Src/util.c    ****       }
1052:Src/util.c    ****     }
1053:Src/util.c    ****   #else
1054:Src/util.c    ****   uint16_t checksum;
1055:Src/util.c    **** 	if (command_in->start == SERIAL_START_FRAME) {
 865              		.loc 1 1055 0
 866 0002 0388     		ldrh	r3, [r0]
 867 0004 4AF6CD34 		movw	r4, #43981
 868 0008 A342     		cmp	r3, r4
 869 000a 01D0     		beq	.L69
 870              	.LVL37:
 871              	.L66:
1056:Src/util.c    **** 		checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
1057:Src/util.c    **** 		if (command_in->checksum == checksum) {					
1058:Src/util.c    **** 			*command_out = *command_in;
1059:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1060:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1061:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1062:Src/util.c    ****         timeoutFlagSerial_L = 0;        // Clear timeout flag
1063:Src/util.c    ****         #endif
1064:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1065:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1066:Src/util.c    ****         timeoutCntSerial_R  = 0;        // Reset timeout counter
1067:Src/util.c    ****         timeoutFlagSerial_R = 0;        // Clear timeout flag
1068:Src/util.c    ****         #endif
1069:Src/util.c    ****       }
1070:Src/util.c    ****     }
1071:Src/util.c    ****   }
1072:Src/util.c    ****   #endif
1073:Src/util.c    **** }
 872              		.loc 1 1073 0
 873 000c 10BC     		pop	{r4}
 874              	.LCFI9:
 875              		.cfi_remember_state
 876              		.cfi_restore 4
 877              		.cfi_def_cfa_offset 0
 878 000e 7047     		bx	lr
 879              	.LVL38:
 880              	.L69:
 881              	.LCFI10:
 882              		.cfi_restore_state
1056:Src/util.c    **** 		checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 883              		.loc 1 1056 0
 884 0010 1BB2     		sxth	r3, r3
 885 0012 B0F90240 		ldrsh	r4, [r0, #2]
 886 0016 6340     		eors	r3, r3, r4
 887 0018 B0F90440 		ldrsh	r4, [r0, #4]
 888 001c 6340     		eors	r3, r3, r4
ARM GAS  /tmp/ccCqBQUf.s 			page 35


 889 001e 9BB2     		uxth	r3, r3
 890              	.LVL39:
1057:Src/util.c    **** 			*command_out = *command_in;
 891              		.loc 1 1057 0
 892 0020 C488     		ldrh	r4, [r0, #6]
 893 0022 A342     		cmp	r3, r4
 894 0024 F2D1     		bne	.L66
1058:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 895              		.loc 1 1058 0
 896 0026 0468     		ldr	r4, [r0]	@ unaligned
 897 0028 4368     		ldr	r3, [r0, #4]	@ unaligned
 898              	.LVL40:
 899 002a 0C60     		str	r4, [r1]	@ unaligned
 900 002c 4B60     		str	r3, [r1, #4]	@ unaligned
1059:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 901              		.loc 1 1059 0
 902 002e 022A     		cmp	r2, #2
 903 0030 ECD0     		beq	.L66
1064:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
 904              		.loc 1 1064 0
 905 0032 032A     		cmp	r2, #3
 906 0034 EAD1     		bne	.L66
1066:Src/util.c    ****         timeoutFlagSerial_R = 0;        // Clear timeout flag
 907              		.loc 1 1066 0
 908 0036 0023     		movs	r3, #0
 909 0038 024A     		ldr	r2, .L70
 910              	.LVL41:
 911 003a 1380     		strh	r3, [r2]	@ movhi
1067:Src/util.c    ****         #endif
 912              		.loc 1 1067 0
 913 003c 024A     		ldr	r2, .L70+4
 914 003e 1370     		strb	r3, [r2]
 915              		.loc 1 1073 0
 916 0040 E4E7     		b	.L66
 917              	.L71:
 918 0042 00BF     		.align	2
 919              	.L70:
 920 0044 00000000 		.word	.LANCHOR4
 921 0048 00000000 		.word	.LANCHOR5
 922              		.cfi_endproc
 923              	.LFE84:
 925              		.section	.text.usart3_rx_check,"ax",%progbits
 926              		.align	1
 927              		.global	usart3_rx_check
 928              		.syntax unified
 929              		.thumb
 930              		.thumb_func
 931              		.fpu softvfp
 933              	usart3_rx_check:
 934              	.LFB83:
 946:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 935              		.loc 1 946 0
 936              		.cfi_startproc
 937              		@ args = 0, pretend = 0, frame = 0
 938              		@ frame_needed = 0, uses_anonymous_args = 0
 939 0000 38B5     		push	{r3, r4, r5, lr}
 940              	.LCFI11:
ARM GAS  /tmp/ccCqBQUf.s 			page 36


 941              		.cfi_def_cfa_offset 16
 942              		.cfi_offset 3, -16
 943              		.cfi_offset 4, -12
 944              		.cfi_offset 5, -8
 945              		.cfi_offset 14, -4
 950:Src/util.c    ****   #endif
 946              		.loc 1 950 0
 947 0002 1E4B     		ldr	r3, .L82
 948 0004 5B6B     		ldr	r3, [r3, #52]
 949 0006 1B68     		ldr	r3, [r3]
 950 0008 5C68     		ldr	r4, [r3, #4]
 951 000a C4F14004 		rsb	r4, r4, #64
 952              	.LVL42:
 968:Src/util.c    ****     ptr = (uint8_t *)&command_raw;                                      // Initialize the pointer w
 953              		.loc 1 968 0
 954 000e 1C4B     		ldr	r3, .L82+4
 955 0010 1B68     		ldr	r3, [r3]
 956 0012 9C42     		cmp	r4, r3
 957 0014 08D0     		beq	.L73
 958              	.LVL43:
 970:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], command_len);                  // Copy data. This is possi
 959              		.loc 1 970 0
 960 0016 02D9     		bls	.L74
 970:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], command_len);                  // Copy data. This is possi
 961              		.loc 1 970 0 is_stmt 0 discriminator 1
 962 0018 E21A     		subs	r2, r4, r3
 963 001a 082A     		cmp	r2, #8
 964 001c 09D0     		beq	.L78
 965              	.L74:
 973:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 966              		.loc 1 973 0 is_stmt 1
 967 001e C3F14005 		rsb	r5, r3, #64
 968 0022 6219     		adds	r2, r4, r5
 969 0024 082A     		cmp	r2, #8
 970 0026 11D0     		beq	.L79
 971              	.LVL44:
 972              	.L73:
1003:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
 973              		.loc 1 1003 0
 974 0028 154B     		ldr	r3, .L82+4
 975 002a 1C60     		str	r4, [r3]
1004:Src/util.c    ****     old_pos = 0;
 976              		.loc 1 1004 0
 977 002c 402C     		cmp	r4, #64
 978 002e 21D0     		beq	.L80
 979              	.L72:
 980 0030 38BD     		pop	{r3, r4, r5, pc}
 981              	.LVL45:
 982              	.L78:
 971:Src/util.c    ****       usart_process_command(&command_raw, &command, 3);                 // Process data
 983              		.loc 1 971 0
 984 0032 1449     		ldr	r1, .L82+8
 985 0034 0B44     		add	r3, r3, r1
 986 0036 144D     		ldr	r5, .L82+12
 987 0038 2A46     		mov	r2, r5
 988 003a 1868     		ldr	r0, [r3]	@ unaligned
 989 003c 5968     		ldr	r1, [r3, #4]	@ unaligned
ARM GAS  /tmp/ccCqBQUf.s 			page 37


 990 003e 03C2     		stmia	r2!, {r0, r1}
 972:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == command_len) {      // "Overflow" buffer mode: 
 991              		.loc 1 972 0
 992 0040 0322     		movs	r2, #3
 993 0042 1249     		ldr	r1, .L82+16
 994 0044 2846     		mov	r0, r5
 995 0046 FFF7FEFF 		bl	usart_process_command
 996              	.LVL46:
 997 004a EDE7     		b	.L73
 998              	.L79:
 974:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 999              		.loc 1 974 0
 1000 004c 2A46     		mov	r2, r5
 1001 004e 0D49     		ldr	r1, .L82+8
 1002 0050 1944     		add	r1, r1, r3
 1003 0052 0D48     		ldr	r0, .L82+12
 1004 0054 FFF7FEFF 		bl	memcpy
 1005              	.LVL47:
 975:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
 1006              		.loc 1 975 0
 1007 0058 2CB9     		cbnz	r4, .L81
 1008              	.LVL48:
 1009              	.L75:
 979:Src/util.c    ****     }
 1010              		.loc 1 979 0
 1011 005a 0322     		movs	r2, #3
 1012 005c 0B49     		ldr	r1, .L82+16
 1013 005e 0A48     		ldr	r0, .L82+12
 1014 0060 FFF7FEFF 		bl	usart_process_command
 1015              	.LVL49:
 1016 0064 E0E7     		b	.L73
 1017              	.LVL50:
 1018              	.L81:
 977:Src/util.c    ****       }
 1019              		.loc 1 977 0
 1020 0066 2246     		mov	r2, r4
 1021 0068 0649     		ldr	r1, .L82+8
 1022 006a 0748     		ldr	r0, .L82+12
 1023 006c 2844     		add	r0, r0, r5
 1024              	.LVL51:
 1025 006e FFF7FEFF 		bl	memcpy
 1026              	.LVL52:
 1027 0072 F2E7     		b	.L75
 1028              	.LVL53:
 1029              	.L80:
1005:Src/util.c    ****   }
 1030              		.loc 1 1005 0
 1031 0074 0022     		movs	r2, #0
 1032 0076 1A60     		str	r2, [r3]
1008:Src/util.c    **** 
 1033              		.loc 1 1008 0
 1034 0078 DAE7     		b	.L72
 1035              	.L83:
 1036 007a 00BF     		.align	2
 1037              	.L82:
 1038 007c 00000000 		.word	huart3
 1039 0080 00000000 		.word	.LANCHOR10
ARM GAS  /tmp/ccCqBQUf.s 			page 38


 1040 0084 00000000 		.word	.LANCHOR2
 1041 0088 00000000 		.word	.LANCHOR11
 1042 008c 00000000 		.word	.LANCHOR3
 1043              		.cfi_endproc
 1044              	.LFE83:
 1046              		.section	.text.sideboardLeds,"ax",%progbits
 1047              		.align	1
 1048              		.global	sideboardLeds
 1049              		.syntax unified
 1050              		.thumb
 1051              		.thumb_func
 1052              		.fpu softvfp
 1054              	sideboardLeds:
 1055              	.LFB85:
1074:Src/util.c    **** #endif
1075:Src/util.c    **** 
1076:Src/util.c    **** /*
1077:Src/util.c    ****  * Process Sideboard Rx data
1078:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1079:Src/util.c    ****  */
1080:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1081:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1082:Src/util.c    **** {	
1083:Src/util.c    ****   uint16_t checksum;
1084:Src/util.c    **** 	if (Sideboard_in->start == SERIAL_START_FRAME) {
1085:Src/util.c    **** 		checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->roll ^ Sideboard_in->pitch ^ Sideboard_
1086:Src/util.c    **** 		if (Sideboard_in->checksum == checksum) {					
1087:Src/util.c    **** 			*Sideboard_out = *Sideboard_in;
1088:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1089:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
1090:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1091:Src/util.c    ****         timeoutFlagSerial_L = 0;        // Clear timeout flag
1092:Src/util.c    ****         #endif
1093:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1094:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1095:Src/util.c    ****         timeoutCntSerial_R  = 0;        // Reset timeout counter
1096:Src/util.c    ****         timeoutFlagSerial_R = 0;        // Clear timeout flag
1097:Src/util.c    ****         #endif
1098:Src/util.c    ****       }
1099:Src/util.c    ****     }
1100:Src/util.c    **** 	}
1101:Src/util.c    **** }
1102:Src/util.c    **** #endif
1103:Src/util.c    **** 
1104:Src/util.c    **** 
1105:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1106:Src/util.c    **** 
1107:Src/util.c    **** /*
1108:Src/util.c    ****  * Sideboard LEDs Handling
1109:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1110:Src/util.c    ****  */
1111:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1056              		.loc 1 1111 0
 1057              		.cfi_startproc
 1058              		@ args = 0, pretend = 0, frame = 0
 1059              		@ frame_needed = 0, uses_anonymous_args = 0
 1060              		@ link register save eliminated.
ARM GAS  /tmp/ccCqBQUf.s 			page 39


 1061              	.LVL54:
 1062 0000 7047     		bx	lr
 1063              		.cfi_endproc
 1064              	.LFE85:
 1066              		.section	.text.sideboardSensors,"ax",%progbits
 1067              		.align	1
 1068              		.global	sideboardSensors
 1069              		.syntax unified
 1070              		.thumb
 1071              		.thumb_func
 1072              		.fpu softvfp
 1074              	sideboardSensors:
 1075              	.LFB86:
1112:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1113:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1114:Src/util.c    ****     // enable == 1, turn on led
1115:Src/util.c    ****     // enable == 0, blink led
1116:Src/util.c    ****     if (enable) {
1117:Src/util.c    ****       *leds |= LED4_SET;
1118:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
1119:Src/util.c    ****       *leds ^= LED4_SET;
1120:Src/util.c    ****     }
1121:Src/util.c    **** 
1122:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1123:Src/util.c    ****     // backwardDrive == 1, blink led
1124:Src/util.c    ****     // backwardDrive == 0, turn off led
1125:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1126:Src/util.c    ****       *leds ^= LED5_SET;
1127:Src/util.c    ****     }
1128:Src/util.c    **** 
1129:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1130:Src/util.c    ****     // brakePressed == 1, turn on led
1131:Src/util.c    ****     // brakePressed == 0, turn off led
1132:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1133:Src/util.c    ****       if (brakePressed) {
1134:Src/util.c    ****         *leds |= LED5_SET;
1135:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1136:Src/util.c    ****         *leds &= ~LED5_SET;
1137:Src/util.c    ****       }
1138:Src/util.c    ****     #endif
1139:Src/util.c    **** 
1140:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1141:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
1142:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1143:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;          
1144:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1145:Src/util.c    ****         *leds ^= LED1_SET;
1146:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1147:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1148:Src/util.c    ****         *leds |= LED1_SET;
1149:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1150:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1151:Src/util.c    ****         *leds ^= LED3_SET;
1152:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1153:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1154:Src/util.c    ****         *leds |= LED3_SET;
1155:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
ARM GAS  /tmp/ccCqBQUf.s 			page 40


1156:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1157:Src/util.c    ****         *leds ^= LED2_SET;
1158:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1159:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1160:Src/util.c    ****         *leds |= LED2_SET;
1161:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1162:Src/util.c    ****       }
1163:Src/util.c    ****     }
1164:Src/util.c    **** 
1165:Src/util.c    ****     // Error handling
1166:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1167:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1168:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1169:Src/util.c    ****       *leds |= LED1_SET;
1170:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1171:Src/util.c    ****     }
1172:Src/util.c    ****     if (timeoutFlagADC || timeoutFlagSerial) {
1173:Src/util.c    ****       *leds |= LED3_SET;
1174:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1175:Src/util.c    ****     }
1176:Src/util.c    ****   #endif
1177:Src/util.c    **** }
1178:Src/util.c    **** 
1179:Src/util.c    **** /*
1180:Src/util.c    ****  * Sideboard Sensor Handling
1181:Src/util.c    ****  * This function manages the sideboards photo sensors.
1182:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
1183:Src/util.c    ****  */
1184:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1076              		.loc 1 1184 0
 1077              		.cfi_startproc
 1078              		@ args = 0, pretend = 0, frame = 0
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080              		@ link register save eliminated.
 1081              	.LVL55:
 1082 0000 7047     		bx	lr
 1083              		.cfi_endproc
 1084              	.LFE86:
 1086              		.section	.text.filtLowPass32,"ax",%progbits
 1087              		.align	1
 1088              		.global	filtLowPass32
 1089              		.syntax unified
 1090              		.thumb
 1091              		.thumb_func
 1092              		.fpu softvfp
 1094              	filtLowPass32:
 1095              	.LFB87:
1185:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1186:Src/util.c    ****     uint8_t sensor1_rising_edge, sensor2_rising_edge;
1187:Src/util.c    ****     sensor1_rising_edge  = (sensors & SENSOR1_SET) && !sensor1_prev;
1188:Src/util.c    ****     sensor2_rising_edge  = (sensors & SENSOR2_SET) && !sensor2_prev;
1189:Src/util.c    ****     sensor1_prev         =  sensors & SENSOR1_SET;
1190:Src/util.c    ****     sensor2_prev         =  sensors & SENSOR2_SET;
1191:Src/util.c    **** 
1192:Src/util.c    ****     // Control MODE and Control Type Handling: use Sensor1 as push button
1193:Src/util.c    ****     if (sensor1_rising_edge) {
1194:Src/util.c    ****       sensor1_index++;
ARM GAS  /tmp/ccCqBQUf.s 			page 41


1195:Src/util.c    ****       if (sensor1_index > 4) { sensor1_index = 0; }
1196:Src/util.c    ****       switch (sensor1_index) {
1197:Src/util.c    ****         case 0:     // FOC VOLTAGE
1198:Src/util.c    ****           rtP_Left.z_ctrlTypSel  = FOC_CTRL;
1199:Src/util.c    ****           rtP_Right.z_ctrlTypSel = FOC_CTRL;
1200:Src/util.c    ****           ctrlModReqRaw          = VLT_MODE;
1201:Src/util.c    ****           break;
1202:Src/util.c    ****         case 1:     // FOC SPEED
1203:Src/util.c    ****           ctrlModReqRaw          = SPD_MODE;
1204:Src/util.c    ****           break;
1205:Src/util.c    ****         case 2:     // FOC TORQUE
1206:Src/util.c    ****           ctrlModReqRaw          = TRQ_MODE;
1207:Src/util.c    ****           break;
1208:Src/util.c    ****         case 3:     // SINUSOIDAL
1209:Src/util.c    ****           rtP_Left.z_ctrlTypSel  = SIN_CTRL;
1210:Src/util.c    ****           rtP_Right.z_ctrlTypSel = SIN_CTRL;
1211:Src/util.c    ****           break;
1212:Src/util.c    ****         case 4:     // COMMUTATION
1213:Src/util.c    ****           rtP_Left.z_ctrlTypSel  = COM_CTRL;
1214:Src/util.c    ****           rtP_Right.z_ctrlTypSel = COM_CTRL;
1215:Src/util.c    ****           break;    
1216:Src/util.c    ****       }
1217:Src/util.c    ****       shortBeepMany(sensor1_index + 1);
1218:Src/util.c    ****     }
1219:Src/util.c    **** 
1220:Src/util.c    ****     // Field Weakening: use Sensor2 as push button
1221:Src/util.c    ****     if (sensor2_rising_edge) {
1222:Src/util.c    ****       sensor2_index++;
1223:Src/util.c    ****       if (sensor2_index > 1) { sensor2_index = 0; }
1224:Src/util.c    ****       switch (sensor2_index) {
1225:Src/util.c    ****         case 0:     // FW Disabled
1226:Src/util.c    ****           rtP_Left.b_fieldWeakEna  = 0; 
1227:Src/util.c    ****           rtP_Right.b_fieldWeakEna = 0;
1228:Src/util.c    ****           Input_Lim_Init();
1229:Src/util.c    ****           break;
1230:Src/util.c    ****         case 1:     // FW Enabled
1231:Src/util.c    ****           rtP_Left.b_fieldWeakEna  = 1; 
1232:Src/util.c    ****           rtP_Right.b_fieldWeakEna = 1;
1233:Src/util.c    ****           Input_Lim_Init();
1234:Src/util.c    ****           break; 
1235:Src/util.c    ****       }
1236:Src/util.c    ****       shortBeepMany(sensor2_index + 1);            
1237:Src/util.c    ****     }
1238:Src/util.c    ****   #endif
1239:Src/util.c    **** }
1240:Src/util.c    **** 
1241:Src/util.c    **** 
1242:Src/util.c    **** 
1243:Src/util.c    **** /* =========================== Filtering Functions =========================== */
1244:Src/util.c    **** 
1245:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1246:Src/util.c    ****   * Max:  32767.99998474121
1247:Src/util.c    ****   * Min: -32768
1248:Src/util.c    ****   * Res:  1.52587890625e-05
1249:Src/util.c    ****   * 
1250:Src/util.c    ****   * Inputs:       u     = int16 or int32
1251:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
ARM GAS  /tmp/ccCqBQUf.s 			page 42


1252:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1253:Src/util.c    ****   * 
1254:Src/util.c    ****   * Example: 
1255:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1256:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
1257:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1258:Src/util.c    ****   */
1259:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 1096              		.loc 1 1259 0
 1097              		.cfi_startproc
 1098              		@ args = 0, pretend = 0, frame = 0
 1099              		@ frame_needed = 0, uses_anonymous_args = 0
 1100              		@ link register save eliminated.
 1101              	.LVL56:
 1102              		.loc 1 1259 0
 1103 0000 2DE97003 		push	{r4, r5, r6, r8, r9}
 1104              	.LCFI12:
 1105              		.cfi_def_cfa_offset 20
 1106              		.cfi_offset 4, -20
 1107              		.cfi_offset 5, -16
 1108              		.cfi_offset 6, -12
 1109              		.cfi_offset 8, -8
 1110              		.cfi_offset 9, -4
1260:Src/util.c    ****   int64_t tmp;  
1261:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 1111              		.loc 1 1261 0
 1112 0004 1668     		ldr	r6, [r2]
 1113 0006 3313     		asrs	r3, r6, #12
 1114 0008 C3EB0010 		rsb	r0, r3, r0, lsl #4
 1115              	.LVL57:
 1116 000c 4FEAE079 		asr	r9, r0, #31
 1117 0010 8CB2     		uxth	r4, r1
 1118 0012 A4FB0001 		umull	r0, r1, r4, r0
 1119 0016 04FB0911 		mla	r1, r4, r9, r1
 1120              	.LVL58:
 1121 001a 0409     		lsrs	r4, r0, #4
 1122              	.LVL59:
 1123 001c 44EA0174 		orr	r4, r4, r1, lsl #28
 1124 0020 0D11     		asrs	r5, r1, #4
 1125              	.LVL60:
1262:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 1126              		.loc 1 1262 0
 1127 0022 B4F1004F 		cmp	r4, #-2147483648
 1128 0026 75F10003 		sbcs	r3, r5, #0
 1129 002a 08DA     		bge	.L89
 1130              		.loc 1 1262 0 is_stmt 0 discriminator 1
 1131 002c 2346     		mov	r3, r4
 1132 002e B4F1004F 		cmp	r4, #-2147483648
 1133 0032 75F1FF31 		sbcs	r1, r5, #-1
 1134 0036 04DA     		bge	.L87
 1135 0038 4FF00043 		mov	r3, #-2147483648
 1136 003c 01E0     		b	.L87
 1137              	.L89:
 1138              		.loc 1 1262 0
 1139 003e 6FF00043 		mvn	r3, #-2147483648
 1140              	.L87:
 1141              	.LVL61:
ARM GAS  /tmp/ccCqBQUf.s 			page 43


1263:Src/util.c    ****   *y = (int32_t)tmp + (*y);
 1142              		.loc 1 1263 0 is_stmt 1 discriminator 4
 1143 0042 1E44     		add	r6, r6, r3
 1144 0044 1660     		str	r6, [r2]
1264:Src/util.c    **** }
 1145              		.loc 1 1264 0 discriminator 4
 1146 0046 BDE87003 		pop	{r4, r5, r6, r8, r9}
 1147              	.LCFI13:
 1148              		.cfi_restore 9
 1149              		.cfi_restore 8
 1150              		.cfi_restore 6
 1151              		.cfi_restore 5
 1152              		.cfi_restore 4
 1153              		.cfi_def_cfa_offset 0
 1154 004a 7047     		bx	lr
 1155              		.cfi_endproc
 1156              	.LFE87:
 1158              		.section	.text.rateLimiter16,"ax",%progbits
 1159              		.align	1
 1160              		.global	rateLimiter16
 1161              		.syntax unified
 1162              		.thumb
 1163              		.thumb_func
 1164              		.fpu softvfp
 1166              	rateLimiter16:
 1167              	.LFB88:
1265:Src/util.c    ****   // Old filter
1266:Src/util.c    ****   // Inputs:       u     = int16
1267:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
1268:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1269:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1270:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1271:Src/util.c    ****   //   int32_t tmp;  
1272:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1273:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1274:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1275:Src/util.c    ****   // }
1276:Src/util.c    **** 
1277:Src/util.c    **** 
1278:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1279:Src/util.c    ****   * Inputs:       u     = int16
1280:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1281:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1282:Src/util.c    ****   */
1283:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 1168              		.loc 1 1283 0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 0
 1171              		@ frame_needed = 0, uses_anonymous_args = 0
 1172              		@ link register save eliminated.
 1173              	.LVL62:
1284:Src/util.c    ****   int16_t q0;
1285:Src/util.c    ****   int16_t q1;
1286:Src/util.c    **** 
1287:Src/util.c    ****   q0 = (u << 4)  - *y;
 1174              		.loc 1 1287 0
 1175 0000 0001     		lsls	r0, r0, #4
ARM GAS  /tmp/ccCqBQUf.s 			page 44


 1176              	.LVL63:
 1177 0002 80B2     		uxth	r0, r0
 1178 0004 1388     		ldrh	r3, [r2]
 1179 0006 C01A     		subs	r0, r0, r3
 1180 0008 00B2     		sxth	r0, r0
 1181              	.LVL64:
1288:Src/util.c    **** 
1289:Src/util.c    ****   if (q0 > rate) {
 1182              		.loc 1 1289 0
 1183 000a 8842     		cmp	r0, r1
 1184 000c 03DC     		bgt	.L92
1290:Src/util.c    ****     q0 = rate;
1291:Src/util.c    ****   } else {
1292:Src/util.c    ****     q1 = -rate;
 1185              		.loc 1 1292 0
 1186 000e 4942     		negs	r1, r1
 1187              	.LVL65:
 1188 0010 09B2     		sxth	r1, r1
 1189              	.LVL66:
1293:Src/util.c    ****     if (q0 < q1) {
 1190              		.loc 1 1293 0
 1191 0012 8842     		cmp	r0, r1
 1192 0014 02DA     		bge	.L93
 1193              	.LVL67:
 1194              	.L92:
1294:Src/util.c    ****       q0 = q1;
1295:Src/util.c    ****     }
1296:Src/util.c    ****   }
1297:Src/util.c    **** 
1298:Src/util.c    ****   *y = q0 + *y;
 1195              		.loc 1 1298 0
 1196 0016 1944     		add	r1, r1, r3
 1197              	.LVL68:
 1198 0018 1180     		strh	r1, [r2]	@ movhi
 1199 001a 7047     		bx	lr
 1200              	.LVL69:
 1201              	.L93:
1287:Src/util.c    **** 
 1202              		.loc 1 1287 0
 1203 001c 0146     		mov	r1, r0
 1204              	.LVL70:
 1205 001e FAE7     		b	.L92
 1206              		.cfi_endproc
 1207              	.LFE88:
 1209              		.section	.text.mixerFcn,"ax",%progbits
 1210              		.align	1
 1211              		.global	mixerFcn
 1212              		.syntax unified
 1213              		.thumb
 1214              		.thumb_func
 1215              		.fpu softvfp
 1217              	mixerFcn:
 1218              	.LFB89:
1299:Src/util.c    **** }
1300:Src/util.c    **** 
1301:Src/util.c    **** 
1302:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
ARM GAS  /tmp/ccCqBQUf.s 			page 45


1303:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1304:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1305:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1306:Src/util.c    ****   */
1307:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 1219              		.loc 1 1307 0
 1220              		.cfi_startproc
 1221              		@ args = 0, pretend = 0, frame = 0
 1222              		@ frame_needed = 0, uses_anonymous_args = 0
 1223              		@ link register save eliminated.
 1224              	.LVL71:
 1225 0000 70B4     		push	{r4, r5, r6}
 1226              	.LCFI14:
 1227              		.cfi_def_cfa_offset 12
 1228              		.cfi_offset 4, -12
 1229              		.cfi_offset 5, -8
 1230              		.cfi_offset 6, -4
 1231              	.LVL72:
1308:Src/util.c    ****   int16_t prodSpeed;
1309:Src/util.c    ****   int16_t prodSteer;
1310:Src/util.c    ****   int32_t tmp;
1311:Src/util.c    **** 
1312:Src/util.c    ****   prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
1313:Src/util.c    ****   prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 1232              		.loc 1 1313 0
 1233 0002 4910     		asrs	r1, r1, #1
 1234              	.LVL73:
1314:Src/util.c    **** 
1315:Src/util.c    ****   tmp         = prodSpeed - prodSteer;  
 1235              		.loc 1 1315 0
 1236 0004 441A     		subs	r4, r0, r1
 1237              	.LVL74:
1316:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 1238              		.loc 1 1316 0
 1239 0006 B4F5004F 		cmp	r4, #32768
 1240 000a 24DA     		bge	.L99
 1241              		.loc 1 1316 0 is_stmt 0 discriminator 1
 1242 000c 164D     		ldr	r5, .L103
 1243 000e AC42     		cmp	r4, r5
 1244 0010 B8BF     		it	lt
 1245 0012 2C46     		movlt	r4, r5
 1246              	.LVL75:
 1247              	.L95:
1317:Src/util.c    ****   *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 1248              		.loc 1 1317 0 is_stmt 1 discriminator 4
 1249 0014 2411     		asrs	r4, r4, #4
 1250              	.LVL76:
1318:Src/util.c    ****   *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 1251              		.loc 1 1318 0 discriminator 4
 1252 0016 154D     		ldr	r5, .L103+4
 1253 0018 B5F90050 		ldrsh	r5, [r5]
 1254 001c AC42     		cmp	r4, r5
 1255 001e 1DDC     		bgt	.L100
 1256              		.loc 1 1318 0 is_stmt 0 discriminator 1
 1257 0020 134E     		ldr	r6, .L103+8
 1258 0022 B6F90060 		ldrsh	r6, [r6]
 1259 0026 B442     		cmp	r4, r6
ARM GAS  /tmp/ccCqBQUf.s 			page 46


 1260 0028 B8BF     		it	lt
 1261 002a 3446     		movlt	r4, r6
 1262              	.L96:
 1263              		.loc 1 1318 0 discriminator 4
 1264 002c 1480     		strh	r4, [r2]	@ movhi
1319:Src/util.c    **** 
1320:Src/util.c    ****   tmp         = prodSpeed + prodSteer;
 1265              		.loc 1 1320 0 is_stmt 1 discriminator 4
 1266 002e 0844     		add	r0, r0, r1
 1267              	.LVL77:
1321:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 1268              		.loc 1 1321 0 discriminator 4
 1269 0030 B0F5004F 		cmp	r0, #32768
 1270 0034 14DA     		bge	.L101
 1271              		.loc 1 1321 0 is_stmt 0 discriminator 1
 1272 0036 0C49     		ldr	r1, .L103
 1273              	.LVL78:
 1274 0038 8842     		cmp	r0, r1
 1275 003a B8BF     		it	lt
 1276 003c 0846     		movlt	r0, r1
 1277              	.LVL79:
 1278              	.L97:
1322:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 1279              		.loc 1 1322 0 is_stmt 1 discriminator 4
 1280 003e 0011     		asrs	r0, r0, #4
 1281              	.LVL80:
1323:Src/util.c    ****   *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 1282              		.loc 1 1323 0 discriminator 4
 1283 0040 8542     		cmp	r5, r0
 1284 0042 05DB     		blt	.L98
 1285              		.loc 1 1323 0 is_stmt 0 discriminator 1
 1286 0044 0A4A     		ldr	r2, .L103+8
 1287              	.LVL81:
 1288 0046 B2F90050 		ldrsh	r5, [r2]
 1289 004a 8542     		cmp	r5, r0
 1290 004c B8BF     		it	lt
 1291 004e 0546     		movlt	r5, r0
 1292              	.L98:
 1293              		.loc 1 1323 0 discriminator 4
 1294 0050 1D80     		strh	r5, [r3]	@ movhi
1324:Src/util.c    **** }
 1295              		.loc 1 1324 0 is_stmt 1 discriminator 4
 1296 0052 70BC     		pop	{r4, r5, r6}
 1297              	.LCFI15:
 1298              		.cfi_remember_state
 1299              		.cfi_restore 6
 1300              		.cfi_restore 5
 1301              		.cfi_restore 4
 1302              		.cfi_def_cfa_offset 0
 1303 0054 7047     		bx	lr
 1304              	.LVL82:
 1305              	.L99:
 1306              	.LCFI16:
 1307              		.cfi_restore_state
1316:Src/util.c    ****   *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 1308              		.loc 1 1316 0
 1309 0056 47F6FF74 		movw	r4, #32767
ARM GAS  /tmp/ccCqBQUf.s 			page 47


 1310              	.LVL83:
 1311 005a DBE7     		b	.L95
 1312              	.LVL84:
 1313              	.L100:
1318:Src/util.c    **** 
 1314              		.loc 1 1318 0
 1315 005c 2C46     		mov	r4, r5
 1316 005e E5E7     		b	.L96
 1317              	.LVL85:
 1318              	.L101:
1321:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 1319              		.loc 1 1321 0
 1320 0060 47F6FF70 		movw	r0, #32767
 1321              	.LVL86:
 1322 0064 EBE7     		b	.L97
 1323              	.L104:
 1324 0066 00BF     		.align	2
 1325              	.L103:
 1326 0068 0080FFFF 		.word	-32768
 1327 006c 00000000 		.word	.LANCHOR0
 1328 0070 00000000 		.word	.LANCHOR1
 1329              		.cfi_endproc
 1330              	.LFE89:
 1332              		.section	.text.multipleTapDet,"ax",%progbits
 1333              		.align	1
 1334              		.global	multipleTapDet
 1335              		.syntax unified
 1336              		.thumb
 1337              		.thumb_func
 1338              		.fpu softvfp
 1340              	multipleTapDet:
 1341              	.LFB90:
1325:Src/util.c    **** 
1326:Src/util.c    **** 
1327:Src/util.c    **** 
1328:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1329:Src/util.c    **** 
1330:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1331:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1332:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1333:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1334:Src/util.c    ****   */
1335:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 1342              		.loc 1 1335 0
 1343              		.cfi_startproc
 1344              		@ args = 0, pretend = 0, frame = 0
 1345              		@ frame_needed = 0, uses_anonymous_args = 0
 1346              		@ link register save eliminated.
 1347              	.LVL87:
 1348 0000 30B4     		push	{r4, r5}
 1349              	.LCFI17:
 1350              		.cfi_def_cfa_offset 8
 1351              		.cfi_offset 4, -8
 1352              		.cfi_offset 5, -4
1336:Src/util.c    ****   uint8_t 	b_timeout;
1337:Src/util.c    ****   uint8_t 	b_hyst;
1338:Src/util.c    ****   uint8_t 	b_pulse;
ARM GAS  /tmp/ccCqBQUf.s 			page 48


1339:Src/util.c    ****   uint8_t 	z_pulseCnt;
1340:Src/util.c    ****   uint8_t   z_pulseCntRst;
1341:Src/util.c    ****   uint32_t 	t_time; 
1342:Src/util.c    **** 
1343:Src/util.c    ****   // Detect hysteresis
1344:Src/util.c    ****   if (x->b_hysteresis) {
 1353              		.loc 1 1344 0
 1354 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 1355 0004 CCB1     		cbz	r4, .L106
1345:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 1356              		.loc 1 1345 0
 1357 0006 C828     		cmp	r0, #200
 1358 0008 D4BF     		ite	le
 1359 000a 0020     		movle	r0, #0
 1360              	.LVL88:
 1361 000c 0120     		movgt	r0, #1
 1362              	.LVL89:
 1363              	.L107:
1346:Src/util.c    ****   } else {
1347:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
1348:Src/util.c    ****   }
1349:Src/util.c    **** 
1350:Src/util.c    ****   // Detect pulse
1351:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 1364              		.loc 1 1351 0
 1365 000e 031B     		subs	r3, r0, r4
 1366 0010 18BF     		it	ne
 1367 0012 0123     		movne	r3, #1
 1368              	.LVL90:
1352:Src/util.c    **** 
1353:Src/util.c    ****   // Save time when first pulse is detected
1354:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 1369              		.loc 1 1354 0
 1370 0014 18B1     		cbz	r0, .L108
 1371              		.loc 1 1354 0 is_stmt 0 discriminator 1
 1372 0016 A042     		cmp	r0, r4
 1373 0018 01D0     		beq	.L108
 1374              		.loc 1 1354 0 discriminator 2
 1375 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 1376 001c 9CB1     		cbz	r4, .L113
 1377              	.L108:
1355:Src/util.c    ****     t_time = timeNow;
1356:Src/util.c    ****   } else {
1357:Src/util.c    ****     t_time = x->t_timePrev;
 1378              		.loc 1 1357 0 is_stmt 1
 1379 001e 1568     		ldr	r5, [r2]
 1380              	.LVL91:
 1381              	.L109:
1358:Src/util.c    ****   }
1359:Src/util.c    **** 
1360:Src/util.c    ****   // Create timeout boolean
1361:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 1382              		.loc 1 1361 0
 1383 0020 491B     		subs	r1, r1, r5
 1384              	.LVL92:
1362:Src/util.c    **** 
1363:Src/util.c    ****   // Create pulse counter
ARM GAS  /tmp/ccCqBQUf.s 			page 49


1364:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 1385              		.loc 1 1364 0
 1386 0022 10B9     		cbnz	r0, .L110
 1387              		.loc 1 1364 0 is_stmt 0 discriminator 1
 1388 0024 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 1389 0026 04B9     		cbnz	r4, .L110
1365:Src/util.c    ****     z_pulseCnt = 0U;
 1390              		.loc 1 1365 0 is_stmt 1
 1391 0028 2346     		mov	r3, r4
 1392              	.LVL93:
 1393              	.L110:
1366:Src/util.c    ****   } else {
1367:Src/util.c    ****     z_pulseCnt = b_pulse;
1368:Src/util.c    ****   }
1369:Src/util.c    **** 
1370:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1371:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 1394              		.loc 1 1371 0
 1395 002a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 1396 002c 032C     		cmp	r4, #3
 1397 002e 0CD8     		bhi	.L115
 1398              		.loc 1 1371 0 is_stmt 0 discriminator 1
 1399 0030 B1F5FA6F 		cmp	r1, #2000
 1400 0034 0AD9     		bls	.L111
1372:Src/util.c    ****     z_pulseCntRst = 0U;
 1401              		.loc 1 1372 0 is_stmt 1
 1402 0036 0024     		movs	r4, #0
 1403 0038 08E0     		b	.L111
 1404              	.LVL94:
 1405              	.L106:
1347:Src/util.c    ****   }
 1406              		.loc 1 1347 0
 1407 003a B0F5167F 		cmp	r0, #600
 1408 003e D4BF     		ite	le
 1409 0040 0020     		movle	r0, #0
 1410              	.LVL95:
 1411 0042 0120     		movgt	r0, #1
 1412              	.LVL96:
 1413 0044 E3E7     		b	.L107
 1414              	.LVL97:
 1415              	.L113:
1355:Src/util.c    ****   } else {
 1416              		.loc 1 1355 0
 1417 0046 0D46     		mov	r5, r1
 1418 0048 EAE7     		b	.L109
 1419              	.LVL98:
 1420              	.L115:
 1421              		.loc 1 1372 0
 1422 004a 0024     		movs	r4, #0
 1423              	.L111:
 1424              	.LVL99:
1373:Src/util.c    ****   } else {
1374:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1375:Src/util.c    ****   }
1376:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 1425              		.loc 1 1376 0
 1426 004c 2344     		add	r3, r3, r4
ARM GAS  /tmp/ccCqBQUf.s 			page 50


 1427              	.LVL100:
 1428 004e DBB2     		uxtb	r3, r3
 1429              	.LVL101:
1377:Src/util.c    **** 
1378:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1379:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 1430              		.loc 1 1379 0
 1431 0050 032B     		cmp	r3, #3
 1432 0052 07D9     		bls	.L112
 1433              		.loc 1 1379 0 is_stmt 0 discriminator 1
 1434 0054 B1F5FA6F 		cmp	r1, #2000
 1435 0058 04D8     		bhi	.L112
1380:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 1436              		.loc 1 1380 0 is_stmt 1
 1437 005a 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1438              	.LVL102:
 1439 005c B1FA81F1 		clz	r1, r1
 1440 0060 4909     		lsrs	r1, r1, #5
 1441 0062 9171     		strb	r1, [r2, #6]
 1442              	.L112:
1381:Src/util.c    ****   }
1382:Src/util.c    **** 
1383:Src/util.c    ****   // Update states
1384:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 1443              		.loc 1 1384 0
 1444 0064 1371     		strb	r3, [r2, #4]
1385:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 1445              		.loc 1 1385 0
 1446 0066 5071     		strb	r0, [r2, #5]
 1447              	.LVL103:
1386:Src/util.c    ****   x->t_timePrev 	  = t_time;
 1448              		.loc 1 1386 0
 1449 0068 1560     		str	r5, [r2]
1387:Src/util.c    **** }
 1450              		.loc 1 1387 0
 1451 006a 30BC     		pop	{r4, r5}
 1452              	.LCFI18:
 1453              		.cfi_restore 5
 1454              		.cfi_restore 4
 1455              		.cfi_def_cfa_offset 0
 1456              	.LVL104:
 1457 006c 7047     		bx	lr
 1458              		.cfi_endproc
 1459              	.LFE90:
 1461              		.global	VirtAddVarTab
 1462              		.global	nunchuk_connected
 1463              		.global	ctrlModReq
 1464              		.global	ctrlModReqRaw
 1465              		.global	timeoutFlagSerial
 1466              		.global	timeoutFlagADC
 1467              		.comm	speedAvgAbs,2,2
 1468              		.comm	speedAvg,2,2
 1469              		.comm	cmd2,2,2
 1470              		.comm	cmd1,2,2
 1471              		.comm	rtY_Right,16,4
 1472              		.comm	rtU_Right,14,4
 1473              		.comm	rtDW_Right,164,4
ARM GAS  /tmp/ccCqBQUf.s 			page 51


 1474              		.comm	rtP_Right,252,4
 1475              		.comm	rtY_Left,16,4
 1476              		.comm	rtU_Left,14,4
 1477              		.comm	rtDW_Left,164,4
 1478              		.global	rtM_Right
 1479              		.global	rtM_Left
 1480              		.comm	rtM_Right_,16,4
 1481              		.comm	rtM_Left_,16,4
 1482              		.section	.bss.INPUT_MAX,"aw",%nobits
 1483              		.align	1
 1484              		.set	.LANCHOR0,. + 0
 1487              	INPUT_MAX:
 1488 0000 0000     		.space	2
 1489              		.section	.bss.INPUT_MIN,"aw",%nobits
 1490              		.align	1
 1491              		.set	.LANCHOR1,. + 0
 1494              	INPUT_MIN:
 1495 0000 0000     		.space	2
 1496              		.section	.bss.command,"aw",%nobits
 1497              		.align	2
 1498              		.set	.LANCHOR3,. + 0
 1501              	command:
 1502 0000 00000000 		.space	8
 1502      00000000 
 1503              		.section	.bss.command_raw,"aw",%nobits
 1504              		.align	2
 1505              		.set	.LANCHOR11,. + 0
 1508              	command_raw:
 1509 0000 00000000 		.space	8
 1509      00000000 
 1510              		.section	.bss.nunchuk_connected,"aw",%nobits
 1513              	nunchuk_connected:
 1514 0000 00       		.space	1
 1515              		.section	.bss.old_pos.8378,"aw",%nobits
 1516              		.align	2
 1517              		.set	.LANCHOR10,. + 0
 1520              	old_pos.8378:
 1521 0000 00000000 		.space	4
 1522              		.section	.bss.rx_buffer_R,"aw",%nobits
 1523              		.align	2
 1524              		.set	.LANCHOR2,. + 0
 1527              	rx_buffer_R:
 1528 0000 00000000 		.space	64
 1528      00000000 
 1528      00000000 
 1528      00000000 
 1528      00000000 
 1529              		.section	.bss.timeoutCntSerial_R,"aw",%nobits
 1530              		.align	1
 1531              		.set	.LANCHOR4,. + 0
 1534              	timeoutCntSerial_R:
 1535 0000 0000     		.space	2
 1536              		.section	.bss.timeoutFlagADC,"aw",%nobits
 1537              		.set	.LANCHOR7,. + 0
 1540              	timeoutFlagADC:
 1541 0000 00       		.space	1
 1542              		.section	.bss.timeoutFlagSerial,"aw",%nobits
ARM GAS  /tmp/ccCqBQUf.s 			page 52


 1543              		.set	.LANCHOR6,. + 0
 1546              	timeoutFlagSerial:
 1547 0000 00       		.space	1
 1548              		.section	.bss.timeoutFlagSerial_R,"aw",%nobits
 1549              		.set	.LANCHOR5,. + 0
 1552              	timeoutFlagSerial_R:
 1553 0000 00       		.space	1
 1554              		.section	.data.VirtAddVarTab,"aw",%progbits
 1555              		.align	2
 1558              	VirtAddVarTab:
 1559 0000 0013     		.short	4864
 1560 0002 00000000 		.space	16
 1560      00000000 
 1560      00000000 
 1560      00000000 
 1561              		.section	.data.ctrlModReq,"aw",%progbits
 1562              		.set	.LANCHOR8,. + 0
 1565              	ctrlModReq:
 1566 0000 01       		.byte	1
 1567              		.section	.data.ctrlModReqRaw,"aw",%progbits
 1568              		.set	.LANCHOR9,. + 0
 1571              	ctrlModReqRaw:
 1572 0000 01       		.byte	1
 1573              		.section	.rodata.poweroff.str1.4,"aMS",%progbits,1
 1574              		.align	2
 1575              	.LC0:
 1576 0000 2D2D204D 		.ascii	"-- Motors disabled --\015\012\000"
 1576      6F746F72 
 1576      73206469 
 1576      7361626C 
 1576      6564202D 
 1577              		.section	.rodata.rtM_Left,"a",%progbits
 1578              		.align	2
 1581              	rtM_Left:
 1582 0000 00000000 		.word	rtM_Left_
 1583              		.section	.rodata.rtM_Right,"a",%progbits
 1584              		.align	2
 1587              	rtM_Right:
 1588 0000 00000000 		.word	rtM_Right_
 1589              		.text
 1590              	.Letext0:
 1591              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1592              		.file 3 "/usr/include/newlib/sys/lock.h"
 1593              		.file 4 "/usr/include/newlib/sys/_types.h"
 1594              		.file 5 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 1595              		.file 6 "/usr/include/newlib/sys/reent.h"
 1596              		.file 7 "/usr/include/newlib/stdlib.h"
 1597              		.file 8 "/usr/include/newlib/sys/_stdint.h"
 1598              		.file 9 "Drivers/CMSIS/Include/core_cm3.h"
 1599              		.file 10 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 1600              		.file 11 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 1601              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 1602              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 1603              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 1604              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_i2c.h"
 1605              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 1606              		.file 17 "Inc/defines.h"
ARM GAS  /tmp/ccCqBQUf.s 			page 53


 1607              		.file 18 "Inc/util.h"
 1608              		.file 19 "Inc/rtwtypes.h"
 1609              		.file 20 "Inc/BLDC_controller.h"
 1610              		.file 21 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 1611              		.file 22 "Inc/comms.h"
 1612              		.file 23 "Inc/setup.h"
ARM GAS  /tmp/ccCqBQUf.s 			page 54


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccCqBQUf.s:16     .text.BLDC_Init:0000000000000000 $t
     /tmp/ccCqBQUf.s:23     .text.BLDC_Init:0000000000000000 BLDC_Init
     /tmp/ccCqBQUf.s:110    .text.BLDC_Init:0000000000000084 $d
                            *COM*:00000000000000fc rtP_Right
                            *COM*:0000000000000010 rtM_Left_
                            *COM*:00000000000000a4 rtDW_Left
                            *COM*:000000000000000e rtU_Left
                            *COM*:0000000000000010 rtY_Left
                            *COM*:0000000000000010 rtM_Right_
                            *COM*:00000000000000a4 rtDW_Right
                            *COM*:000000000000000e rtU_Right
                            *COM*:0000000000000010 rtY_Right
     /tmp/ccCqBQUf.s:124    .text.Input_Lim_Init:0000000000000000 $t
     /tmp/ccCqBQUf.s:131    .text.Input_Lim_Init:0000000000000000 Input_Lim_Init
     /tmp/ccCqBQUf.s:168    .text.Input_Lim_Init:0000000000000034 $d
     /tmp/ccCqBQUf.s:176    .text.UART_DisableRxErrors:0000000000000000 $t
     /tmp/ccCqBQUf.s:183    .text.UART_DisableRxErrors:0000000000000000 UART_DisableRxErrors
     /tmp/ccCqBQUf.s:206    .text.Input_Init:0000000000000000 $t
     /tmp/ccCqBQUf.s:213    .text.Input_Init:0000000000000000 Input_Init
     /tmp/ccCqBQUf.s:242    .text.Input_Init:000000000000001c $d
     /tmp/ccCqBQUf.s:248    .text.poweronMelody:0000000000000000 $t
     /tmp/ccCqBQUf.s:255    .text.poweronMelody:0000000000000000 poweronMelody
     /tmp/ccCqBQUf.s:297    .text.poweronMelody:0000000000000020 $d
     /tmp/ccCqBQUf.s:302    .text.shortBeep:0000000000000000 $t
     /tmp/ccCqBQUf.s:309    .text.shortBeep:0000000000000000 shortBeep
     /tmp/ccCqBQUf.s:336    .text.shortBeep:0000000000000014 $d
     /tmp/ccCqBQUf.s:341    .text.shortBeepMany:0000000000000000 $t
     /tmp/ccCqBQUf.s:348    .text.shortBeepMany:0000000000000000 shortBeepMany
     /tmp/ccCqBQUf.s:391    .text.longBeep:0000000000000000 $t
     /tmp/ccCqBQUf.s:398    .text.longBeep:0000000000000000 longBeep
     /tmp/ccCqBQUf.s:425    .text.longBeep:0000000000000014 $d
     /tmp/ccCqBQUf.s:430    .text.calcAvgSpeed:0000000000000000 $t
     /tmp/ccCqBQUf.s:437    .text.calcAvgSpeed:0000000000000000 calcAvgSpeed
     /tmp/ccCqBQUf.s:464    .text.calcAvgSpeed:0000000000000028 $d
                            *COM*:0000000000000002 speedAvg
                            *COM*:0000000000000002 speedAvgAbs
     /tmp/ccCqBQUf.s:472    .text.adcCalibLim:0000000000000000 $t
     /tmp/ccCqBQUf.s:479    .text.adcCalibLim:0000000000000000 adcCalibLim
     /tmp/ccCqBQUf.s:491    .text.updateCurSpdLim:0000000000000000 $t
     /tmp/ccCqBQUf.s:498    .text.updateCurSpdLim:0000000000000000 updateCurSpdLim
     /tmp/ccCqBQUf.s:510    .text.saveConfig:0000000000000000 $t
     /tmp/ccCqBQUf.s:517    .text.saveConfig:0000000000000000 saveConfig
     /tmp/ccCqBQUf.s:529    .text.addDeadBand:0000000000000000 $t
     /tmp/ccCqBQUf.s:536    .text.addDeadBand:0000000000000000 addDeadBand
     /tmp/ccCqBQUf.s:552    .text.standstillHold:0000000000000000 $t
     /tmp/ccCqBQUf.s:559    .text.standstillHold:0000000000000000 standstillHold
     /tmp/ccCqBQUf.s:572    .text.electricBrake:0000000000000000 $t
     /tmp/ccCqBQUf.s:579    .text.electricBrake:0000000000000000 electricBrake
     /tmp/ccCqBQUf.s:592    .text.poweroff:0000000000000000 $t
     /tmp/ccCqBQUf.s:599    .text.poweroff:0000000000000000 poweroff
     /tmp/ccCqBQUf.s:653    .text.poweroff:0000000000000030 $d
     /tmp/ccCqBQUf.s:662    .text.poweroffPressCheck:0000000000000000 $t
     /tmp/ccCqBQUf.s:669    .text.poweroffPressCheck:0000000000000000 poweroffPressCheck
     /tmp/ccCqBQUf.s:706    .text.poweroffPressCheck:0000000000000024 $d
     /tmp/ccCqBQUf.s:712    .text.readCommand:0000000000000000 $t
ARM GAS  /tmp/ccCqBQUf.s 			page 55


     /tmp/ccCqBQUf.s:719    .text.readCommand:0000000000000000 readCommand
     /tmp/ccCqBQUf.s:810    .text.readCommand:0000000000000080 $d
                            *COM*:0000000000000002 cmd1
                            *COM*:0000000000000002 cmd2
     /tmp/ccCqBQUf.s:826    .text.usart2_rx_check:0000000000000000 $t
     /tmp/ccCqBQUf.s:833    .text.usart2_rx_check:0000000000000000 usart2_rx_check
     /tmp/ccCqBQUf.s:845    .text.usart_process_command:0000000000000000 $t
     /tmp/ccCqBQUf.s:852    .text.usart_process_command:0000000000000000 usart_process_command
     /tmp/ccCqBQUf.s:920    .text.usart_process_command:0000000000000044 $d
     /tmp/ccCqBQUf.s:926    .text.usart3_rx_check:0000000000000000 $t
     /tmp/ccCqBQUf.s:933    .text.usart3_rx_check:0000000000000000 usart3_rx_check
     /tmp/ccCqBQUf.s:1038   .text.usart3_rx_check:000000000000007c $d
     /tmp/ccCqBQUf.s:1047   .text.sideboardLeds:0000000000000000 $t
     /tmp/ccCqBQUf.s:1054   .text.sideboardLeds:0000000000000000 sideboardLeds
     /tmp/ccCqBQUf.s:1067   .text.sideboardSensors:0000000000000000 $t
     /tmp/ccCqBQUf.s:1074   .text.sideboardSensors:0000000000000000 sideboardSensors
     /tmp/ccCqBQUf.s:1087   .text.filtLowPass32:0000000000000000 $t
     /tmp/ccCqBQUf.s:1094   .text.filtLowPass32:0000000000000000 filtLowPass32
     /tmp/ccCqBQUf.s:1159   .text.rateLimiter16:0000000000000000 $t
     /tmp/ccCqBQUf.s:1166   .text.rateLimiter16:0000000000000000 rateLimiter16
     /tmp/ccCqBQUf.s:1210   .text.mixerFcn:0000000000000000 $t
     /tmp/ccCqBQUf.s:1217   .text.mixerFcn:0000000000000000 mixerFcn
     /tmp/ccCqBQUf.s:1326   .text.mixerFcn:0000000000000068 $d
     /tmp/ccCqBQUf.s:1333   .text.multipleTapDet:0000000000000000 $t
     /tmp/ccCqBQUf.s:1340   .text.multipleTapDet:0000000000000000 multipleTapDet
     /tmp/ccCqBQUf.s:1558   .data.VirtAddVarTab:0000000000000000 VirtAddVarTab
     /tmp/ccCqBQUf.s:1513   .bss.nunchuk_connected:0000000000000000 nunchuk_connected
     /tmp/ccCqBQUf.s:1565   .data.ctrlModReq:0000000000000000 ctrlModReq
     /tmp/ccCqBQUf.s:1571   .data.ctrlModReqRaw:0000000000000000 ctrlModReqRaw
     /tmp/ccCqBQUf.s:1546   .bss.timeoutFlagSerial:0000000000000000 timeoutFlagSerial
     /tmp/ccCqBQUf.s:1540   .bss.timeoutFlagADC:0000000000000000 timeoutFlagADC
     /tmp/ccCqBQUf.s:1587   .rodata.rtM_Right:0000000000000000 rtM_Right
     /tmp/ccCqBQUf.s:1581   .rodata.rtM_Left:0000000000000000 rtM_Left
     /tmp/ccCqBQUf.s:1483   .bss.INPUT_MAX:0000000000000000 $d
     /tmp/ccCqBQUf.s:1487   .bss.INPUT_MAX:0000000000000000 INPUT_MAX
     /tmp/ccCqBQUf.s:1490   .bss.INPUT_MIN:0000000000000000 $d
     /tmp/ccCqBQUf.s:1494   .bss.INPUT_MIN:0000000000000000 INPUT_MIN
     /tmp/ccCqBQUf.s:1497   .bss.command:0000000000000000 $d
     /tmp/ccCqBQUf.s:1501   .bss.command:0000000000000000 command
     /tmp/ccCqBQUf.s:1504   .bss.command_raw:0000000000000000 $d
     /tmp/ccCqBQUf.s:1508   .bss.command_raw:0000000000000000 command_raw
     /tmp/ccCqBQUf.s:1514   .bss.nunchuk_connected:0000000000000000 $d
     /tmp/ccCqBQUf.s:1516   .bss.old_pos.8378:0000000000000000 $d
     /tmp/ccCqBQUf.s:1520   .bss.old_pos.8378:0000000000000000 old_pos.8378
     /tmp/ccCqBQUf.s:1523   .bss.rx_buffer_R:0000000000000000 $d
     /tmp/ccCqBQUf.s:1527   .bss.rx_buffer_R:0000000000000000 rx_buffer_R
     /tmp/ccCqBQUf.s:1530   .bss.timeoutCntSerial_R:0000000000000000 $d
     /tmp/ccCqBQUf.s:1534   .bss.timeoutCntSerial_R:0000000000000000 timeoutCntSerial_R
     /tmp/ccCqBQUf.s:1541   .bss.timeoutFlagADC:0000000000000000 $d
     /tmp/ccCqBQUf.s:1547   .bss.timeoutFlagSerial:0000000000000000 $d
     /tmp/ccCqBQUf.s:1552   .bss.timeoutFlagSerial_R:0000000000000000 timeoutFlagSerial_R
     /tmp/ccCqBQUf.s:1553   .bss.timeoutFlagSerial_R:0000000000000000 $d
     /tmp/ccCqBQUf.s:1555   .data.VirtAddVarTab:0000000000000000 $d
     /tmp/ccCqBQUf.s:1574   .rodata.poweroff.str1.4:0000000000000000 $d
     /tmp/ccCqBQUf.s:1578   .rodata.rtM_Left:0000000000000000 $d
     /tmp/ccCqBQUf.s:1584   .rodata.rtM_Right:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
ARM GAS  /tmp/ccCqBQUf.s 			page 56



UNDEFINED SYMBOLS
memcpy
BLDC_controller_initialize
rtP_Left
UART3_Init
HAL_UART_Receive_DMA
huart3
HAL_Delay
buzzerFreq
consoleLog
HAL_GPIO_WritePin
buzzerPattern
enable
HAL_GPIO_ReadPin
timeoutCnt
